// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package server

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/parrotmac/littleblue/pkg/internal/models"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AggregateBuildJob struct {
		Count func(childComplexity int) int
	}

	AggregateDockerRegistry struct {
		Count func(childComplexity int) int
	}

	AggregateSourceRepository struct {
		Count func(childComplexity int) int
	}

	AggregateUser struct {
		Count func(childComplexity int) int
	}

	BatchPayload struct {
		Count func(childComplexity int) int
	}

	BuildJob struct {
		ArtifactURI         func(childComplexity int) int
		BuildHostIdentifier func(childComplexity int) int
		BuildHostKind       func(childComplexity int) int
		BuildIdentifier     func(childComplexity int) int
		BuildLogs           func(childComplexity int) int
		CompletedAt         func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		ID                  func(childComplexity int) int
		PushLogs            func(childComplexity int) int
		Repo                func(childComplexity int) int
		SetupLogs           func(childComplexity int) int
		SourceRevision      func(childComplexity int) int
		Status              func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
	}

	BuildJobConnection struct {
		Aggregate func(childComplexity int) int
		Edges     func(childComplexity int) int
		PageInfo  func(childComplexity int) int
	}

	BuildJobEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BuildJobPreviousValues struct {
		ArtifactURI         func(childComplexity int) int
		BuildHostIdentifier func(childComplexity int) int
		BuildHostKind       func(childComplexity int) int
		BuildIdentifier     func(childComplexity int) int
		BuildLogs           func(childComplexity int) int
		CompletedAt         func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		ID                  func(childComplexity int) int
		PushLogs            func(childComplexity int) int
		SetupLogs           func(childComplexity int) int
		SourceRevision      func(childComplexity int) int
		Status              func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
	}

	BuildJobSubscriptionPayload struct {
		Mutation       func(childComplexity int) int
		Node           func(childComplexity int) int
		PreviousValues func(childComplexity int) int
		UpdatedFields  func(childComplexity int) int
	}

	DockerRegistry struct {
		AuthPassword func(childComplexity int) int
		AuthUsername func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Hostname     func(childComplexity int) int
		ID           func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	DockerRegistryConnection struct {
		Aggregate func(childComplexity int) int
		Edges     func(childComplexity int) int
		PageInfo  func(childComplexity int) int
	}

	DockerRegistryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	DockerRegistryPreviousValues struct {
		AuthPassword func(childComplexity int) int
		AuthUsername func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Hostname     func(childComplexity int) int
		ID           func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	DockerRegistrySubscriptionPayload struct {
		Mutation       func(childComplexity int) int
		Node           func(childComplexity int) int
		PreviousValues func(childComplexity int) int
		UpdatedFields  func(childComplexity int) int
	}

	Mutation struct {
		CreateBuildJob               func(childComplexity int, data models.BuildJobCreateInput) int
		CreateDockerRegistry         func(childComplexity int, data models.DockerRegistryCreateInput) int
		CreateSourceRepository       func(childComplexity int, data models.SourceRepositoryCreateInput) int
		CreateUser                   func(childComplexity int, data models.UserCreateInput) int
		DeleteBuildJob               func(childComplexity int, where models.BuildJobWhereUniqueInput) int
		DeleteDockerRegistry         func(childComplexity int, where models.DockerRegistryWhereUniqueInput) int
		DeleteManyBuildJobs          func(childComplexity int, where *models.BuildJobWhereInput) int
		DeleteManyDockerRegistries   func(childComplexity int, where *models.DockerRegistryWhereInput) int
		DeleteManySourceRepositories func(childComplexity int, where *models.SourceRepositoryWhereInput) int
		DeleteManyUsers              func(childComplexity int, where *models.UserWhereInput) int
		DeleteSourceRepository       func(childComplexity int, where models.SourceRepositoryWhereUniqueInput) int
		DeleteUser                   func(childComplexity int, where models.UserWhereUniqueInput) int
		UpdateBuildJob               func(childComplexity int, data models.BuildJobUpdateInput, where models.BuildJobWhereUniqueInput) int
		UpdateDockerRegistry         func(childComplexity int, data models.DockerRegistryUpdateInput, where models.DockerRegistryWhereUniqueInput) int
		UpdateManyBuildJobs          func(childComplexity int, data models.BuildJobUpdateManyMutationInput, where *models.BuildJobWhereInput) int
		UpdateManyDockerRegistries   func(childComplexity int, data models.DockerRegistryUpdateManyMutationInput, where *models.DockerRegistryWhereInput) int
		UpdateManySourceRepositories func(childComplexity int, data models.SourceRepositoryUpdateManyMutationInput, where *models.SourceRepositoryWhereInput) int
		UpdateManyUsers              func(childComplexity int, data models.UserUpdateManyMutationInput, where *models.UserWhereInput) int
		UpdateSourceRepository       func(childComplexity int, data models.SourceRepositoryUpdateInput, where models.SourceRepositoryWhereUniqueInput) int
		UpdateUser                   func(childComplexity int, data models.UserUpdateInput, where models.UserWhereUniqueInput) int
		UpsertBuildJob               func(childComplexity int, where models.BuildJobWhereUniqueInput, create models.BuildJobCreateInput, update models.BuildJobUpdateInput) int
		UpsertDockerRegistry         func(childComplexity int, where models.DockerRegistryWhereUniqueInput, create models.DockerRegistryCreateInput, update models.DockerRegistryUpdateInput) int
		UpsertSourceRepository       func(childComplexity int, where models.SourceRepositoryWhereUniqueInput, create models.SourceRepositoryCreateInput, update models.SourceRepositoryUpdateInput) int
		UpsertUser                   func(childComplexity int, where models.UserWhereUniqueInput, create models.UserCreateInput, update models.UserUpdateInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		BuildJob                     func(childComplexity int, where models.BuildJobWhereUniqueInput) int
		BuildJobs                    func(childComplexity int, where *models.BuildJobWhereInput, orderBy *models.BuildJobOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
		BuildJobsConnection          func(childComplexity int, where *models.BuildJobWhereInput, orderBy *models.BuildJobOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
		DockerRegistries             func(childComplexity int, where *models.DockerRegistryWhereInput, orderBy *models.DockerRegistryOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
		DockerRegistriesConnection   func(childComplexity int, where *models.DockerRegistryWhereInput, orderBy *models.DockerRegistryOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
		DockerRegistry               func(childComplexity int, where models.DockerRegistryWhereUniqueInput) int
		Node                         func(childComplexity int, id string) int
		SourceRepositories           func(childComplexity int, where *models.SourceRepositoryWhereInput, orderBy *models.SourceRepositoryOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
		SourceRepositoriesConnection func(childComplexity int, where *models.SourceRepositoryWhereInput, orderBy *models.SourceRepositoryOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
		SourceRepository             func(childComplexity int, where models.SourceRepositoryWhereUniqueInput) int
		User                         func(childComplexity int, where models.UserWhereUniqueInput) int
		Users                        func(childComplexity int, where *models.UserWhereInput, orderBy *models.UserOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
		UsersConnection              func(childComplexity int, where *models.UserWhereInput, orderBy *models.UserOrderByInput, skip *int, after *string, before *string, first *int, last *int) int
	}

	SourceRepository struct {
		AuthClientID              func(childComplexity int) int
		AuthSecret                func(childComplexity int) int
		BaseConfigurationFileName func(childComplexity int) int
		BuildsEnabled             func(childComplexity int) int
		CloneStrategy             func(childComplexity int) int
		CreatedAt                 func(childComplexity int) int
		ID                        func(childComplexity int) int
		Name                      func(childComplexity int) int
		Owner                     func(childComplexity int) int
		SourceProvider            func(childComplexity int) int
		UpdatedAt                 func(childComplexity int) int
	}

	SourceRepositoryConnection struct {
		Aggregate func(childComplexity int) int
		Edges     func(childComplexity int) int
		PageInfo  func(childComplexity int) int
	}

	SourceRepositoryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	SourceRepositoryPreviousValues struct {
		AuthClientID              func(childComplexity int) int
		AuthSecret                func(childComplexity int) int
		BaseConfigurationFileName func(childComplexity int) int
		BuildsEnabled             func(childComplexity int) int
		CloneStrategy             func(childComplexity int) int
		CreatedAt                 func(childComplexity int) int
		ID                        func(childComplexity int) int
		Name                      func(childComplexity int) int
		SourceProvider            func(childComplexity int) int
		UpdatedAt                 func(childComplexity int) int
	}

	SourceRepositorySubscriptionPayload struct {
		Mutation       func(childComplexity int) int
		Node           func(childComplexity int) int
		PreviousValues func(childComplexity int) int
		UpdatedFields  func(childComplexity int) int
	}

	Subscription struct {
		BuildJob         func(childComplexity int, where *models.BuildJobSubscriptionWhereInput) int
		DockerRegistry   func(childComplexity int, where *models.DockerRegistrySubscriptionWhereInput) int
		SourceRepository func(childComplexity int, where *models.SourceRepositorySubscriptionWhereInput) int
		User             func(childComplexity int, where *models.UserSubscriptionWhereInput) int
	}

	User struct {
		CreatedAt              func(childComplexity int) int
		Email                  func(childComplexity int) int
		GithubAccountAuthToken func(childComplexity int) int
		GithubUsername         func(childComplexity int) int
		GoogleAccountAuthToken func(childComplexity int) int
		ID                     func(childComplexity int) int
		Name                   func(childComplexity int) int
		PasswordHash           func(childComplexity int) int
		UpdatedAt              func(childComplexity int) int
	}

	UserConnection struct {
		Aggregate func(childComplexity int) int
		Edges     func(childComplexity int) int
		PageInfo  func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserPreviousValues struct {
		CreatedAt              func(childComplexity int) int
		Email                  func(childComplexity int) int
		GithubAccountAuthToken func(childComplexity int) int
		GithubUsername         func(childComplexity int) int
		GoogleAccountAuthToken func(childComplexity int) int
		ID                     func(childComplexity int) int
		Name                   func(childComplexity int) int
		PasswordHash           func(childComplexity int) int
		UpdatedAt              func(childComplexity int) int
	}

	UserSubscriptionPayload struct {
		Mutation       func(childComplexity int) int
		Node           func(childComplexity int) int
		PreviousValues func(childComplexity int) int
		UpdatedFields  func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateBuildJob(ctx context.Context, data models.BuildJobCreateInput) (*models.BuildJob, error)
	UpdateBuildJob(ctx context.Context, data models.BuildJobUpdateInput, where models.BuildJobWhereUniqueInput) (*models.BuildJob, error)
	UpdateManyBuildJobs(ctx context.Context, data models.BuildJobUpdateManyMutationInput, where *models.BuildJobWhereInput) (*models.BatchPayload, error)
	UpsertBuildJob(ctx context.Context, where models.BuildJobWhereUniqueInput, create models.BuildJobCreateInput, update models.BuildJobUpdateInput) (*models.BuildJob, error)
	DeleteBuildJob(ctx context.Context, where models.BuildJobWhereUniqueInput) (*models.BuildJob, error)
	DeleteManyBuildJobs(ctx context.Context, where *models.BuildJobWhereInput) (*models.BatchPayload, error)
	CreateDockerRegistry(ctx context.Context, data models.DockerRegistryCreateInput) (*models.DockerRegistry, error)
	UpdateDockerRegistry(ctx context.Context, data models.DockerRegistryUpdateInput, where models.DockerRegistryWhereUniqueInput) (*models.DockerRegistry, error)
	UpdateManyDockerRegistries(ctx context.Context, data models.DockerRegistryUpdateManyMutationInput, where *models.DockerRegistryWhereInput) (*models.BatchPayload, error)
	UpsertDockerRegistry(ctx context.Context, where models.DockerRegistryWhereUniqueInput, create models.DockerRegistryCreateInput, update models.DockerRegistryUpdateInput) (*models.DockerRegistry, error)
	DeleteDockerRegistry(ctx context.Context, where models.DockerRegistryWhereUniqueInput) (*models.DockerRegistry, error)
	DeleteManyDockerRegistries(ctx context.Context, where *models.DockerRegistryWhereInput) (*models.BatchPayload, error)
	CreateSourceRepository(ctx context.Context, data models.SourceRepositoryCreateInput) (*models.SourceRepository, error)
	UpdateSourceRepository(ctx context.Context, data models.SourceRepositoryUpdateInput, where models.SourceRepositoryWhereUniqueInput) (*models.SourceRepository, error)
	UpdateManySourceRepositories(ctx context.Context, data models.SourceRepositoryUpdateManyMutationInput, where *models.SourceRepositoryWhereInput) (*models.BatchPayload, error)
	UpsertSourceRepository(ctx context.Context, where models.SourceRepositoryWhereUniqueInput, create models.SourceRepositoryCreateInput, update models.SourceRepositoryUpdateInput) (*models.SourceRepository, error)
	DeleteSourceRepository(ctx context.Context, where models.SourceRepositoryWhereUniqueInput) (*models.SourceRepository, error)
	DeleteManySourceRepositories(ctx context.Context, where *models.SourceRepositoryWhereInput) (*models.BatchPayload, error)
	CreateUser(ctx context.Context, data models.UserCreateInput) (*models.User, error)
	UpdateUser(ctx context.Context, data models.UserUpdateInput, where models.UserWhereUniqueInput) (*models.User, error)
	UpdateManyUsers(ctx context.Context, data models.UserUpdateManyMutationInput, where *models.UserWhereInput) (*models.BatchPayload, error)
	UpsertUser(ctx context.Context, where models.UserWhereUniqueInput, create models.UserCreateInput, update models.UserUpdateInput) (*models.User, error)
	DeleteUser(ctx context.Context, where models.UserWhereUniqueInput) (*models.User, error)
	DeleteManyUsers(ctx context.Context, where *models.UserWhereInput) (*models.BatchPayload, error)
}
type QueryResolver interface {
	BuildJob(ctx context.Context, where models.BuildJobWhereUniqueInput) (*models.BuildJob, error)
	BuildJobs(ctx context.Context, where *models.BuildJobWhereInput, orderBy *models.BuildJobOrderByInput, skip *int, after *string, before *string, first *int, last *int) ([]*models.BuildJob, error)
	BuildJobsConnection(ctx context.Context, where *models.BuildJobWhereInput, orderBy *models.BuildJobOrderByInput, skip *int, after *string, before *string, first *int, last *int) (*models.BuildJobConnection, error)
	DockerRegistry(ctx context.Context, where models.DockerRegistryWhereUniqueInput) (*models.DockerRegistry, error)
	DockerRegistries(ctx context.Context, where *models.DockerRegistryWhereInput, orderBy *models.DockerRegistryOrderByInput, skip *int, after *string, before *string, first *int, last *int) ([]*models.DockerRegistry, error)
	DockerRegistriesConnection(ctx context.Context, where *models.DockerRegistryWhereInput, orderBy *models.DockerRegistryOrderByInput, skip *int, after *string, before *string, first *int, last *int) (*models.DockerRegistryConnection, error)
	SourceRepository(ctx context.Context, where models.SourceRepositoryWhereUniqueInput) (*models.SourceRepository, error)
	SourceRepositories(ctx context.Context, where *models.SourceRepositoryWhereInput, orderBy *models.SourceRepositoryOrderByInput, skip *int, after *string, before *string, first *int, last *int) ([]*models.SourceRepository, error)
	SourceRepositoriesConnection(ctx context.Context, where *models.SourceRepositoryWhereInput, orderBy *models.SourceRepositoryOrderByInput, skip *int, after *string, before *string, first *int, last *int) (*models.SourceRepositoryConnection, error)
	User(ctx context.Context, where models.UserWhereUniqueInput) (*models.User, error)
	Users(ctx context.Context, where *models.UserWhereInput, orderBy *models.UserOrderByInput, skip *int, after *string, before *string, first *int, last *int) ([]*models.User, error)
	UsersConnection(ctx context.Context, where *models.UserWhereInput, orderBy *models.UserOrderByInput, skip *int, after *string, before *string, first *int, last *int) (*models.UserConnection, error)
	Node(ctx context.Context, id string) (models.Node, error)
}
type SubscriptionResolver interface {
	BuildJob(ctx context.Context, where *models.BuildJobSubscriptionWhereInput) (<-chan *models.BuildJobSubscriptionPayload, error)
	DockerRegistry(ctx context.Context, where *models.DockerRegistrySubscriptionWhereInput) (<-chan *models.DockerRegistrySubscriptionPayload, error)
	SourceRepository(ctx context.Context, where *models.SourceRepositorySubscriptionWhereInput) (<-chan *models.SourceRepositorySubscriptionPayload, error)
	User(ctx context.Context, where *models.UserSubscriptionWhereInput) (<-chan *models.UserSubscriptionPayload, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AggregateBuildJob.count":
		if e.complexity.AggregateBuildJob.Count == nil {
			break
		}

		return e.complexity.AggregateBuildJob.Count(childComplexity), true

	case "AggregateDockerRegistry.count":
		if e.complexity.AggregateDockerRegistry.Count == nil {
			break
		}

		return e.complexity.AggregateDockerRegistry.Count(childComplexity), true

	case "AggregateSourceRepository.count":
		if e.complexity.AggregateSourceRepository.Count == nil {
			break
		}

		return e.complexity.AggregateSourceRepository.Count(childComplexity), true

	case "AggregateUser.count":
		if e.complexity.AggregateUser.Count == nil {
			break
		}

		return e.complexity.AggregateUser.Count(childComplexity), true

	case "BatchPayload.count":
		if e.complexity.BatchPayload.Count == nil {
			break
		}

		return e.complexity.BatchPayload.Count(childComplexity), true

	case "BuildJob.artifactUri":
		if e.complexity.BuildJob.ArtifactURI == nil {
			break
		}

		return e.complexity.BuildJob.ArtifactURI(childComplexity), true

	case "BuildJob.buildHostIdentifier":
		if e.complexity.BuildJob.BuildHostIdentifier == nil {
			break
		}

		return e.complexity.BuildJob.BuildHostIdentifier(childComplexity), true

	case "BuildJob.buildHostKind":
		if e.complexity.BuildJob.BuildHostKind == nil {
			break
		}

		return e.complexity.BuildJob.BuildHostKind(childComplexity), true

	case "BuildJob.buildIdentifier":
		if e.complexity.BuildJob.BuildIdentifier == nil {
			break
		}

		return e.complexity.BuildJob.BuildIdentifier(childComplexity), true

	case "BuildJob.buildLogs":
		if e.complexity.BuildJob.BuildLogs == nil {
			break
		}

		return e.complexity.BuildJob.BuildLogs(childComplexity), true

	case "BuildJob.completedAt":
		if e.complexity.BuildJob.CompletedAt == nil {
			break
		}

		return e.complexity.BuildJob.CompletedAt(childComplexity), true

	case "BuildJob.createdAt":
		if e.complexity.BuildJob.CreatedAt == nil {
			break
		}

		return e.complexity.BuildJob.CreatedAt(childComplexity), true

	case "BuildJob.id":
		if e.complexity.BuildJob.ID == nil {
			break
		}

		return e.complexity.BuildJob.ID(childComplexity), true

	case "BuildJob.pushLogs":
		if e.complexity.BuildJob.PushLogs == nil {
			break
		}

		return e.complexity.BuildJob.PushLogs(childComplexity), true

	case "BuildJob.repo":
		if e.complexity.BuildJob.Repo == nil {
			break
		}

		return e.complexity.BuildJob.Repo(childComplexity), true

	case "BuildJob.setupLogs":
		if e.complexity.BuildJob.SetupLogs == nil {
			break
		}

		return e.complexity.BuildJob.SetupLogs(childComplexity), true

	case "BuildJob.sourceRevision":
		if e.complexity.BuildJob.SourceRevision == nil {
			break
		}

		return e.complexity.BuildJob.SourceRevision(childComplexity), true

	case "BuildJob.status":
		if e.complexity.BuildJob.Status == nil {
			break
		}

		return e.complexity.BuildJob.Status(childComplexity), true

	case "BuildJob.updatedAt":
		if e.complexity.BuildJob.UpdatedAt == nil {
			break
		}

		return e.complexity.BuildJob.UpdatedAt(childComplexity), true

	case "BuildJobConnection.aggregate":
		if e.complexity.BuildJobConnection.Aggregate == nil {
			break
		}

		return e.complexity.BuildJobConnection.Aggregate(childComplexity), true

	case "BuildJobConnection.edges":
		if e.complexity.BuildJobConnection.Edges == nil {
			break
		}

		return e.complexity.BuildJobConnection.Edges(childComplexity), true

	case "BuildJobConnection.pageInfo":
		if e.complexity.BuildJobConnection.PageInfo == nil {
			break
		}

		return e.complexity.BuildJobConnection.PageInfo(childComplexity), true

	case "BuildJobEdge.cursor":
		if e.complexity.BuildJobEdge.Cursor == nil {
			break
		}

		return e.complexity.BuildJobEdge.Cursor(childComplexity), true

	case "BuildJobEdge.node":
		if e.complexity.BuildJobEdge.Node == nil {
			break
		}

		return e.complexity.BuildJobEdge.Node(childComplexity), true

	case "BuildJobPreviousValues.artifactUri":
		if e.complexity.BuildJobPreviousValues.ArtifactURI == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.ArtifactURI(childComplexity), true

	case "BuildJobPreviousValues.buildHostIdentifier":
		if e.complexity.BuildJobPreviousValues.BuildHostIdentifier == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.BuildHostIdentifier(childComplexity), true

	case "BuildJobPreviousValues.buildHostKind":
		if e.complexity.BuildJobPreviousValues.BuildHostKind == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.BuildHostKind(childComplexity), true

	case "BuildJobPreviousValues.buildIdentifier":
		if e.complexity.BuildJobPreviousValues.BuildIdentifier == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.BuildIdentifier(childComplexity), true

	case "BuildJobPreviousValues.buildLogs":
		if e.complexity.BuildJobPreviousValues.BuildLogs == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.BuildLogs(childComplexity), true

	case "BuildJobPreviousValues.completedAt":
		if e.complexity.BuildJobPreviousValues.CompletedAt == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.CompletedAt(childComplexity), true

	case "BuildJobPreviousValues.createdAt":
		if e.complexity.BuildJobPreviousValues.CreatedAt == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.CreatedAt(childComplexity), true

	case "BuildJobPreviousValues.id":
		if e.complexity.BuildJobPreviousValues.ID == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.ID(childComplexity), true

	case "BuildJobPreviousValues.pushLogs":
		if e.complexity.BuildJobPreviousValues.PushLogs == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.PushLogs(childComplexity), true

	case "BuildJobPreviousValues.setupLogs":
		if e.complexity.BuildJobPreviousValues.SetupLogs == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.SetupLogs(childComplexity), true

	case "BuildJobPreviousValues.sourceRevision":
		if e.complexity.BuildJobPreviousValues.SourceRevision == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.SourceRevision(childComplexity), true

	case "BuildJobPreviousValues.status":
		if e.complexity.BuildJobPreviousValues.Status == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.Status(childComplexity), true

	case "BuildJobPreviousValues.updatedAt":
		if e.complexity.BuildJobPreviousValues.UpdatedAt == nil {
			break
		}

		return e.complexity.BuildJobPreviousValues.UpdatedAt(childComplexity), true

	case "BuildJobSubscriptionPayload.mutation":
		if e.complexity.BuildJobSubscriptionPayload.Mutation == nil {
			break
		}

		return e.complexity.BuildJobSubscriptionPayload.Mutation(childComplexity), true

	case "BuildJobSubscriptionPayload.node":
		if e.complexity.BuildJobSubscriptionPayload.Node == nil {
			break
		}

		return e.complexity.BuildJobSubscriptionPayload.Node(childComplexity), true

	case "BuildJobSubscriptionPayload.previousValues":
		if e.complexity.BuildJobSubscriptionPayload.PreviousValues == nil {
			break
		}

		return e.complexity.BuildJobSubscriptionPayload.PreviousValues(childComplexity), true

	case "BuildJobSubscriptionPayload.updatedFields":
		if e.complexity.BuildJobSubscriptionPayload.UpdatedFields == nil {
			break
		}

		return e.complexity.BuildJobSubscriptionPayload.UpdatedFields(childComplexity), true

	case "DockerRegistry.AuthPassword":
		if e.complexity.DockerRegistry.AuthPassword == nil {
			break
		}

		return e.complexity.DockerRegistry.AuthPassword(childComplexity), true

	case "DockerRegistry.AuthUsername":
		if e.complexity.DockerRegistry.AuthUsername == nil {
			break
		}

		return e.complexity.DockerRegistry.AuthUsername(childComplexity), true

	case "DockerRegistry.createdAt":
		if e.complexity.DockerRegistry.CreatedAt == nil {
			break
		}

		return e.complexity.DockerRegistry.CreatedAt(childComplexity), true

	case "DockerRegistry.Hostname":
		if e.complexity.DockerRegistry.Hostname == nil {
			break
		}

		return e.complexity.DockerRegistry.Hostname(childComplexity), true

	case "DockerRegistry.id":
		if e.complexity.DockerRegistry.ID == nil {
			break
		}

		return e.complexity.DockerRegistry.ID(childComplexity), true

	case "DockerRegistry.updatedAt":
		if e.complexity.DockerRegistry.UpdatedAt == nil {
			break
		}

		return e.complexity.DockerRegistry.UpdatedAt(childComplexity), true

	case "DockerRegistryConnection.aggregate":
		if e.complexity.DockerRegistryConnection.Aggregate == nil {
			break
		}

		return e.complexity.DockerRegistryConnection.Aggregate(childComplexity), true

	case "DockerRegistryConnection.edges":
		if e.complexity.DockerRegistryConnection.Edges == nil {
			break
		}

		return e.complexity.DockerRegistryConnection.Edges(childComplexity), true

	case "DockerRegistryConnection.pageInfo":
		if e.complexity.DockerRegistryConnection.PageInfo == nil {
			break
		}

		return e.complexity.DockerRegistryConnection.PageInfo(childComplexity), true

	case "DockerRegistryEdge.cursor":
		if e.complexity.DockerRegistryEdge.Cursor == nil {
			break
		}

		return e.complexity.DockerRegistryEdge.Cursor(childComplexity), true

	case "DockerRegistryEdge.node":
		if e.complexity.DockerRegistryEdge.Node == nil {
			break
		}

		return e.complexity.DockerRegistryEdge.Node(childComplexity), true

	case "DockerRegistryPreviousValues.AuthPassword":
		if e.complexity.DockerRegistryPreviousValues.AuthPassword == nil {
			break
		}

		return e.complexity.DockerRegistryPreviousValues.AuthPassword(childComplexity), true

	case "DockerRegistryPreviousValues.AuthUsername":
		if e.complexity.DockerRegistryPreviousValues.AuthUsername == nil {
			break
		}

		return e.complexity.DockerRegistryPreviousValues.AuthUsername(childComplexity), true

	case "DockerRegistryPreviousValues.createdAt":
		if e.complexity.DockerRegistryPreviousValues.CreatedAt == nil {
			break
		}

		return e.complexity.DockerRegistryPreviousValues.CreatedAt(childComplexity), true

	case "DockerRegistryPreviousValues.Hostname":
		if e.complexity.DockerRegistryPreviousValues.Hostname == nil {
			break
		}

		return e.complexity.DockerRegistryPreviousValues.Hostname(childComplexity), true

	case "DockerRegistryPreviousValues.id":
		if e.complexity.DockerRegistryPreviousValues.ID == nil {
			break
		}

		return e.complexity.DockerRegistryPreviousValues.ID(childComplexity), true

	case "DockerRegistryPreviousValues.updatedAt":
		if e.complexity.DockerRegistryPreviousValues.UpdatedAt == nil {
			break
		}

		return e.complexity.DockerRegistryPreviousValues.UpdatedAt(childComplexity), true

	case "DockerRegistrySubscriptionPayload.mutation":
		if e.complexity.DockerRegistrySubscriptionPayload.Mutation == nil {
			break
		}

		return e.complexity.DockerRegistrySubscriptionPayload.Mutation(childComplexity), true

	case "DockerRegistrySubscriptionPayload.node":
		if e.complexity.DockerRegistrySubscriptionPayload.Node == nil {
			break
		}

		return e.complexity.DockerRegistrySubscriptionPayload.Node(childComplexity), true

	case "DockerRegistrySubscriptionPayload.previousValues":
		if e.complexity.DockerRegistrySubscriptionPayload.PreviousValues == nil {
			break
		}

		return e.complexity.DockerRegistrySubscriptionPayload.PreviousValues(childComplexity), true

	case "DockerRegistrySubscriptionPayload.updatedFields":
		if e.complexity.DockerRegistrySubscriptionPayload.UpdatedFields == nil {
			break
		}

		return e.complexity.DockerRegistrySubscriptionPayload.UpdatedFields(childComplexity), true

	case "Mutation.createBuildJob":
		if e.complexity.Mutation.CreateBuildJob == nil {
			break
		}

		args, err := ec.field_Mutation_createBuildJob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBuildJob(childComplexity, args["data"].(models.BuildJobCreateInput)), true

	case "Mutation.createDockerRegistry":
		if e.complexity.Mutation.CreateDockerRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_createDockerRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDockerRegistry(childComplexity, args["data"].(models.DockerRegistryCreateInput)), true

	case "Mutation.createSourceRepository":
		if e.complexity.Mutation.CreateSourceRepository == nil {
			break
		}

		args, err := ec.field_Mutation_createSourceRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSourceRepository(childComplexity, args["data"].(models.SourceRepositoryCreateInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["data"].(models.UserCreateInput)), true

	case "Mutation.deleteBuildJob":
		if e.complexity.Mutation.DeleteBuildJob == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBuildJob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBuildJob(childComplexity, args["where"].(models.BuildJobWhereUniqueInput)), true

	case "Mutation.deleteDockerRegistry":
		if e.complexity.Mutation.DeleteDockerRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDockerRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDockerRegistry(childComplexity, args["where"].(models.DockerRegistryWhereUniqueInput)), true

	case "Mutation.deleteManyBuildJobs":
		if e.complexity.Mutation.DeleteManyBuildJobs == nil {
			break
		}

		args, err := ec.field_Mutation_deleteManyBuildJobs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteManyBuildJobs(childComplexity, args["where"].(*models.BuildJobWhereInput)), true

	case "Mutation.deleteManyDockerRegistries":
		if e.complexity.Mutation.DeleteManyDockerRegistries == nil {
			break
		}

		args, err := ec.field_Mutation_deleteManyDockerRegistries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteManyDockerRegistries(childComplexity, args["where"].(*models.DockerRegistryWhereInput)), true

	case "Mutation.deleteManySourceRepositories":
		if e.complexity.Mutation.DeleteManySourceRepositories == nil {
			break
		}

		args, err := ec.field_Mutation_deleteManySourceRepositories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteManySourceRepositories(childComplexity, args["where"].(*models.SourceRepositoryWhereInput)), true

	case "Mutation.deleteManyUsers":
		if e.complexity.Mutation.DeleteManyUsers == nil {
			break
		}

		args, err := ec.field_Mutation_deleteManyUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteManyUsers(childComplexity, args["where"].(*models.UserWhereInput)), true

	case "Mutation.deleteSourceRepository":
		if e.complexity.Mutation.DeleteSourceRepository == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSourceRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSourceRepository(childComplexity, args["where"].(models.SourceRepositoryWhereUniqueInput)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["where"].(models.UserWhereUniqueInput)), true

	case "Mutation.updateBuildJob":
		if e.complexity.Mutation.UpdateBuildJob == nil {
			break
		}

		args, err := ec.field_Mutation_updateBuildJob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBuildJob(childComplexity, args["data"].(models.BuildJobUpdateInput), args["where"].(models.BuildJobWhereUniqueInput)), true

	case "Mutation.updateDockerRegistry":
		if e.complexity.Mutation.UpdateDockerRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_updateDockerRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDockerRegistry(childComplexity, args["data"].(models.DockerRegistryUpdateInput), args["where"].(models.DockerRegistryWhereUniqueInput)), true

	case "Mutation.updateManyBuildJobs":
		if e.complexity.Mutation.UpdateManyBuildJobs == nil {
			break
		}

		args, err := ec.field_Mutation_updateManyBuildJobs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateManyBuildJobs(childComplexity, args["data"].(models.BuildJobUpdateManyMutationInput), args["where"].(*models.BuildJobWhereInput)), true

	case "Mutation.updateManyDockerRegistries":
		if e.complexity.Mutation.UpdateManyDockerRegistries == nil {
			break
		}

		args, err := ec.field_Mutation_updateManyDockerRegistries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateManyDockerRegistries(childComplexity, args["data"].(models.DockerRegistryUpdateManyMutationInput), args["where"].(*models.DockerRegistryWhereInput)), true

	case "Mutation.updateManySourceRepositories":
		if e.complexity.Mutation.UpdateManySourceRepositories == nil {
			break
		}

		args, err := ec.field_Mutation_updateManySourceRepositories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateManySourceRepositories(childComplexity, args["data"].(models.SourceRepositoryUpdateManyMutationInput), args["where"].(*models.SourceRepositoryWhereInput)), true

	case "Mutation.updateManyUsers":
		if e.complexity.Mutation.UpdateManyUsers == nil {
			break
		}

		args, err := ec.field_Mutation_updateManyUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateManyUsers(childComplexity, args["data"].(models.UserUpdateManyMutationInput), args["where"].(*models.UserWhereInput)), true

	case "Mutation.updateSourceRepository":
		if e.complexity.Mutation.UpdateSourceRepository == nil {
			break
		}

		args, err := ec.field_Mutation_updateSourceRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSourceRepository(childComplexity, args["data"].(models.SourceRepositoryUpdateInput), args["where"].(models.SourceRepositoryWhereUniqueInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["data"].(models.UserUpdateInput), args["where"].(models.UserWhereUniqueInput)), true

	case "Mutation.upsertBuildJob":
		if e.complexity.Mutation.UpsertBuildJob == nil {
			break
		}

		args, err := ec.field_Mutation_upsertBuildJob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertBuildJob(childComplexity, args["where"].(models.BuildJobWhereUniqueInput), args["create"].(models.BuildJobCreateInput), args["update"].(models.BuildJobUpdateInput)), true

	case "Mutation.upsertDockerRegistry":
		if e.complexity.Mutation.UpsertDockerRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_upsertDockerRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertDockerRegistry(childComplexity, args["where"].(models.DockerRegistryWhereUniqueInput), args["create"].(models.DockerRegistryCreateInput), args["update"].(models.DockerRegistryUpdateInput)), true

	case "Mutation.upsertSourceRepository":
		if e.complexity.Mutation.UpsertSourceRepository == nil {
			break
		}

		args, err := ec.field_Mutation_upsertSourceRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertSourceRepository(childComplexity, args["where"].(models.SourceRepositoryWhereUniqueInput), args["create"].(models.SourceRepositoryCreateInput), args["update"].(models.SourceRepositoryUpdateInput)), true

	case "Mutation.upsertUser":
		if e.complexity.Mutation.UpsertUser == nil {
			break
		}

		args, err := ec.field_Mutation_upsertUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertUser(childComplexity, args["where"].(models.UserWhereUniqueInput), args["create"].(models.UserCreateInput), args["update"].(models.UserUpdateInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.buildJob":
		if e.complexity.Query.BuildJob == nil {
			break
		}

		args, err := ec.field_Query_buildJob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildJob(childComplexity, args["where"].(models.BuildJobWhereUniqueInput)), true

	case "Query.buildJobs":
		if e.complexity.Query.BuildJobs == nil {
			break
		}

		args, err := ec.field_Query_buildJobs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildJobs(childComplexity, args["where"].(*models.BuildJobWhereInput), args["orderBy"].(*models.BuildJobOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.buildJobsConnection":
		if e.complexity.Query.BuildJobsConnection == nil {
			break
		}

		args, err := ec.field_Query_buildJobsConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildJobsConnection(childComplexity, args["where"].(*models.BuildJobWhereInput), args["orderBy"].(*models.BuildJobOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.dockerRegistries":
		if e.complexity.Query.DockerRegistries == nil {
			break
		}

		args, err := ec.field_Query_dockerRegistries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DockerRegistries(childComplexity, args["where"].(*models.DockerRegistryWhereInput), args["orderBy"].(*models.DockerRegistryOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.dockerRegistriesConnection":
		if e.complexity.Query.DockerRegistriesConnection == nil {
			break
		}

		args, err := ec.field_Query_dockerRegistriesConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DockerRegistriesConnection(childComplexity, args["where"].(*models.DockerRegistryWhereInput), args["orderBy"].(*models.DockerRegistryOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.dockerRegistry":
		if e.complexity.Query.DockerRegistry == nil {
			break
		}

		args, err := ec.field_Query_dockerRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DockerRegistry(childComplexity, args["where"].(models.DockerRegistryWhereUniqueInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.sourceRepositories":
		if e.complexity.Query.SourceRepositories == nil {
			break
		}

		args, err := ec.field_Query_sourceRepositories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SourceRepositories(childComplexity, args["where"].(*models.SourceRepositoryWhereInput), args["orderBy"].(*models.SourceRepositoryOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.sourceRepositoriesConnection":
		if e.complexity.Query.SourceRepositoriesConnection == nil {
			break
		}

		args, err := ec.field_Query_sourceRepositoriesConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SourceRepositoriesConnection(childComplexity, args["where"].(*models.SourceRepositoryWhereInput), args["orderBy"].(*models.SourceRepositoryOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.sourceRepository":
		if e.complexity.Query.SourceRepository == nil {
			break
		}

		args, err := ec.field_Query_sourceRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SourceRepository(childComplexity, args["where"].(models.SourceRepositoryWhereUniqueInput)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["where"].(models.UserWhereUniqueInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["where"].(*models.UserWhereInput), args["orderBy"].(*models.UserOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.usersConnection":
		if e.complexity.Query.UsersConnection == nil {
			break
		}

		args, err := ec.field_Query_usersConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UsersConnection(childComplexity, args["where"].(*models.UserWhereInput), args["orderBy"].(*models.UserOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "SourceRepository.authClientID":
		if e.complexity.SourceRepository.AuthClientID == nil {
			break
		}

		return e.complexity.SourceRepository.AuthClientID(childComplexity), true

	case "SourceRepository.authSecret":
		if e.complexity.SourceRepository.AuthSecret == nil {
			break
		}

		return e.complexity.SourceRepository.AuthSecret(childComplexity), true

	case "SourceRepository.baseConfigurationFileName":
		if e.complexity.SourceRepository.BaseConfigurationFileName == nil {
			break
		}

		return e.complexity.SourceRepository.BaseConfigurationFileName(childComplexity), true

	case "SourceRepository.buildsEnabled":
		if e.complexity.SourceRepository.BuildsEnabled == nil {
			break
		}

		return e.complexity.SourceRepository.BuildsEnabled(childComplexity), true

	case "SourceRepository.cloneStrategy":
		if e.complexity.SourceRepository.CloneStrategy == nil {
			break
		}

		return e.complexity.SourceRepository.CloneStrategy(childComplexity), true

	case "SourceRepository.createdAt":
		if e.complexity.SourceRepository.CreatedAt == nil {
			break
		}

		return e.complexity.SourceRepository.CreatedAt(childComplexity), true

	case "SourceRepository.id":
		if e.complexity.SourceRepository.ID == nil {
			break
		}

		return e.complexity.SourceRepository.ID(childComplexity), true

	case "SourceRepository.name":
		if e.complexity.SourceRepository.Name == nil {
			break
		}

		return e.complexity.SourceRepository.Name(childComplexity), true

	case "SourceRepository.owner":
		if e.complexity.SourceRepository.Owner == nil {
			break
		}

		return e.complexity.SourceRepository.Owner(childComplexity), true

	case "SourceRepository.sourceProvider":
		if e.complexity.SourceRepository.SourceProvider == nil {
			break
		}

		return e.complexity.SourceRepository.SourceProvider(childComplexity), true

	case "SourceRepository.updatedAt":
		if e.complexity.SourceRepository.UpdatedAt == nil {
			break
		}

		return e.complexity.SourceRepository.UpdatedAt(childComplexity), true

	case "SourceRepositoryConnection.aggregate":
		if e.complexity.SourceRepositoryConnection.Aggregate == nil {
			break
		}

		return e.complexity.SourceRepositoryConnection.Aggregate(childComplexity), true

	case "SourceRepositoryConnection.edges":
		if e.complexity.SourceRepositoryConnection.Edges == nil {
			break
		}

		return e.complexity.SourceRepositoryConnection.Edges(childComplexity), true

	case "SourceRepositoryConnection.pageInfo":
		if e.complexity.SourceRepositoryConnection.PageInfo == nil {
			break
		}

		return e.complexity.SourceRepositoryConnection.PageInfo(childComplexity), true

	case "SourceRepositoryEdge.cursor":
		if e.complexity.SourceRepositoryEdge.Cursor == nil {
			break
		}

		return e.complexity.SourceRepositoryEdge.Cursor(childComplexity), true

	case "SourceRepositoryEdge.node":
		if e.complexity.SourceRepositoryEdge.Node == nil {
			break
		}

		return e.complexity.SourceRepositoryEdge.Node(childComplexity), true

	case "SourceRepositoryPreviousValues.authClientID":
		if e.complexity.SourceRepositoryPreviousValues.AuthClientID == nil {
			break
		}

		return e.complexity.SourceRepositoryPreviousValues.AuthClientID(childComplexity), true

	case "SourceRepositoryPreviousValues.authSecret":
		if e.complexity.SourceRepositoryPreviousValues.AuthSecret == nil {
			break
		}

		return e.complexity.SourceRepositoryPreviousValues.AuthSecret(childComplexity), true

	case "SourceRepositoryPreviousValues.baseConfigurationFileName":
		if e.complexity.SourceRepositoryPreviousValues.BaseConfigurationFileName == nil {
			break
		}

		return e.complexity.SourceRepositoryPreviousValues.BaseConfigurationFileName(childComplexity), true

	case "SourceRepositoryPreviousValues.buildsEnabled":
		if e.complexity.SourceRepositoryPreviousValues.BuildsEnabled == nil {
			break
		}

		return e.complexity.SourceRepositoryPreviousValues.BuildsEnabled(childComplexity), true

	case "SourceRepositoryPreviousValues.cloneStrategy":
		if e.complexity.SourceRepositoryPreviousValues.CloneStrategy == nil {
			break
		}

		return e.complexity.SourceRepositoryPreviousValues.CloneStrategy(childComplexity), true

	case "SourceRepositoryPreviousValues.createdAt":
		if e.complexity.SourceRepositoryPreviousValues.CreatedAt == nil {
			break
		}

		return e.complexity.SourceRepositoryPreviousValues.CreatedAt(childComplexity), true

	case "SourceRepositoryPreviousValues.id":
		if e.complexity.SourceRepositoryPreviousValues.ID == nil {
			break
		}

		return e.complexity.SourceRepositoryPreviousValues.ID(childComplexity), true

	case "SourceRepositoryPreviousValues.name":
		if e.complexity.SourceRepositoryPreviousValues.Name == nil {
			break
		}

		return e.complexity.SourceRepositoryPreviousValues.Name(childComplexity), true

	case "SourceRepositoryPreviousValues.sourceProvider":
		if e.complexity.SourceRepositoryPreviousValues.SourceProvider == nil {
			break
		}

		return e.complexity.SourceRepositoryPreviousValues.SourceProvider(childComplexity), true

	case "SourceRepositoryPreviousValues.updatedAt":
		if e.complexity.SourceRepositoryPreviousValues.UpdatedAt == nil {
			break
		}

		return e.complexity.SourceRepositoryPreviousValues.UpdatedAt(childComplexity), true

	case "SourceRepositorySubscriptionPayload.mutation":
		if e.complexity.SourceRepositorySubscriptionPayload.Mutation == nil {
			break
		}

		return e.complexity.SourceRepositorySubscriptionPayload.Mutation(childComplexity), true

	case "SourceRepositorySubscriptionPayload.node":
		if e.complexity.SourceRepositorySubscriptionPayload.Node == nil {
			break
		}

		return e.complexity.SourceRepositorySubscriptionPayload.Node(childComplexity), true

	case "SourceRepositorySubscriptionPayload.previousValues":
		if e.complexity.SourceRepositorySubscriptionPayload.PreviousValues == nil {
			break
		}

		return e.complexity.SourceRepositorySubscriptionPayload.PreviousValues(childComplexity), true

	case "SourceRepositorySubscriptionPayload.updatedFields":
		if e.complexity.SourceRepositorySubscriptionPayload.UpdatedFields == nil {
			break
		}

		return e.complexity.SourceRepositorySubscriptionPayload.UpdatedFields(childComplexity), true

	case "Subscription.buildJob":
		if e.complexity.Subscription.BuildJob == nil {
			break
		}

		args, err := ec.field_Subscription_buildJob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.BuildJob(childComplexity, args["where"].(*models.BuildJobSubscriptionWhereInput)), true

	case "Subscription.dockerRegistry":
		if e.complexity.Subscription.DockerRegistry == nil {
			break
		}

		args, err := ec.field_Subscription_dockerRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.DockerRegistry(childComplexity, args["where"].(*models.DockerRegistrySubscriptionWhereInput)), true

	case "Subscription.sourceRepository":
		if e.complexity.Subscription.SourceRepository == nil {
			break
		}

		args, err := ec.field_Subscription_sourceRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.SourceRepository(childComplexity, args["where"].(*models.SourceRepositorySubscriptionWhereInput)), true

	case "Subscription.user":
		if e.complexity.Subscription.User == nil {
			break
		}

		args, err := ec.field_Subscription_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.User(childComplexity, args["where"].(*models.UserSubscriptionWhereInput)), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.githubAccountAuthToken":
		if e.complexity.User.GithubAccountAuthToken == nil {
			break
		}

		return e.complexity.User.GithubAccountAuthToken(childComplexity), true

	case "User.githubUsername":
		if e.complexity.User.GithubUsername == nil {
			break
		}

		return e.complexity.User.GithubUsername(childComplexity), true

	case "User.googleAccountAuthToken":
		if e.complexity.User.GoogleAccountAuthToken == nil {
			break
		}

		return e.complexity.User.GoogleAccountAuthToken(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.passwordHash":
		if e.complexity.User.PasswordHash == nil {
			break
		}

		return e.complexity.User.PasswordHash(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "UserConnection.aggregate":
		if e.complexity.UserConnection.Aggregate == nil {
			break
		}

		return e.complexity.UserConnection.Aggregate(childComplexity), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	case "UserPreviousValues.createdAt":
		if e.complexity.UserPreviousValues.CreatedAt == nil {
			break
		}

		return e.complexity.UserPreviousValues.CreatedAt(childComplexity), true

	case "UserPreviousValues.email":
		if e.complexity.UserPreviousValues.Email == nil {
			break
		}

		return e.complexity.UserPreviousValues.Email(childComplexity), true

	case "UserPreviousValues.githubAccountAuthToken":
		if e.complexity.UserPreviousValues.GithubAccountAuthToken == nil {
			break
		}

		return e.complexity.UserPreviousValues.GithubAccountAuthToken(childComplexity), true

	case "UserPreviousValues.githubUsername":
		if e.complexity.UserPreviousValues.GithubUsername == nil {
			break
		}

		return e.complexity.UserPreviousValues.GithubUsername(childComplexity), true

	case "UserPreviousValues.googleAccountAuthToken":
		if e.complexity.UserPreviousValues.GoogleAccountAuthToken == nil {
			break
		}

		return e.complexity.UserPreviousValues.GoogleAccountAuthToken(childComplexity), true

	case "UserPreviousValues.id":
		if e.complexity.UserPreviousValues.ID == nil {
			break
		}

		return e.complexity.UserPreviousValues.ID(childComplexity), true

	case "UserPreviousValues.name":
		if e.complexity.UserPreviousValues.Name == nil {
			break
		}

		return e.complexity.UserPreviousValues.Name(childComplexity), true

	case "UserPreviousValues.passwordHash":
		if e.complexity.UserPreviousValues.PasswordHash == nil {
			break
		}

		return e.complexity.UserPreviousValues.PasswordHash(childComplexity), true

	case "UserPreviousValues.updatedAt":
		if e.complexity.UserPreviousValues.UpdatedAt == nil {
			break
		}

		return e.complexity.UserPreviousValues.UpdatedAt(childComplexity), true

	case "UserSubscriptionPayload.mutation":
		if e.complexity.UserSubscriptionPayload.Mutation == nil {
			break
		}

		return e.complexity.UserSubscriptionPayload.Mutation(childComplexity), true

	case "UserSubscriptionPayload.node":
		if e.complexity.UserSubscriptionPayload.Node == nil {
			break
		}

		return e.complexity.UserSubscriptionPayload.Node(childComplexity), true

	case "UserSubscriptionPayload.previousValues":
		if e.complexity.UserSubscriptionPayload.PreviousValues == nil {
			break
		}

		return e.complexity.UserSubscriptionPayload.PreviousValues(childComplexity), true

	case "UserSubscriptionPayload.updatedFields":
		if e.complexity.UserSubscriptionPayload.UpdatedFields == nil {
			break
		}

		return e.complexity.UserSubscriptionPayload.UpdatedFields(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	next := ec._Subscription(ctx, op.SelectionSet)
	if ec.Errors != nil {
		return graphql.OneShot(&graphql.Response{Data: []byte("null"), Errors: ec.Errors})
	}

	var buf bytes.Buffer
	return func() *graphql.Response {
		buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)
			return buf.Bytes()
		})

		if buf == nil {
			return nil
		}

		return &graphql.Response{
			Data:       buf,
			Errors:     ec.Errors,
			Extensions: ec.Extensions,
		}
	}
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema/generated.graphql", Input: `type AggregateBuildJob {
  count: Int!
}

type AggregateDockerRegistry {
  count: Int!
}

type AggregateSourceRepository {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

enum BuildHost {
  LINUX_AMD64
  LINUX_AARCH64
  WINDOWS_AMD64
}

type BuildJob {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  completedAt: DateTime
  buildHostKind: BuildHost!
  buildHostIdentifier: String
  repo: SourceRepository!
  status: BuildJobStatus!
  buildIdentifier: String!
  sourceRevision: String!
  artifactUri: String!
  setupLogs: String
  buildLogs: String
  pushLogs: String
}

type BuildJobConnection {
  pageInfo: PageInfo!
  edges: [BuildJobEdge]!
  aggregate: AggregateBuildJob!
}

input BuildJobCreateInput {
  id: ID
  completedAt: DateTime
  buildHostKind: BuildHost!
  buildHostIdentifier: String
  repo: SourceRepositoryCreateOneInput!
  status: BuildJobStatus!
  buildIdentifier: String!
  sourceRevision: String!
  artifactUri: String!
  setupLogs: String
  buildLogs: String
  pushLogs: String
}

type BuildJobEdge {
  node: BuildJob!
  cursor: String!
}

enum BuildJobOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  completedAt_ASC
  completedAt_DESC
  buildHostKind_ASC
  buildHostKind_DESC
  buildHostIdentifier_ASC
  buildHostIdentifier_DESC
  status_ASC
  status_DESC
  buildIdentifier_ASC
  buildIdentifier_DESC
  sourceRevision_ASC
  sourceRevision_DESC
  artifactUri_ASC
  artifactUri_DESC
  setupLogs_ASC
  setupLogs_DESC
  buildLogs_ASC
  buildLogs_DESC
  pushLogs_ASC
  pushLogs_DESC
}

type BuildJobPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  completedAt: DateTime
  buildHostKind: BuildHost!
  buildHostIdentifier: String
  status: BuildJobStatus!
  buildIdentifier: String!
  sourceRevision: String!
  artifactUri: String!
  setupLogs: String
  buildLogs: String
  pushLogs: String
}

enum BuildJobStatus {
  Unknown
  Created
  Pending
  Cloning
  PreparingBuild
  Building
  Pushing
  Complete
}

type BuildJobSubscriptionPayload {
  mutation: MutationType!
  node: BuildJob
  updatedFields: [String!]
  previousValues: BuildJobPreviousValues
}

input BuildJobSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BuildJobWhereInput
  AND: [BuildJobSubscriptionWhereInput!]
  OR: [BuildJobSubscriptionWhereInput!]
  NOT: [BuildJobSubscriptionWhereInput!]
}

input BuildJobUpdateInput {
  completedAt: DateTime
  buildHostKind: BuildHost
  buildHostIdentifier: String
  repo: SourceRepositoryUpdateOneRequiredInput
  status: BuildJobStatus
  buildIdentifier: String
  sourceRevision: String
  artifactUri: String
  setupLogs: String
  buildLogs: String
  pushLogs: String
}

input BuildJobUpdateManyMutationInput {
  completedAt: DateTime
  buildHostKind: BuildHost
  buildHostIdentifier: String
  status: BuildJobStatus
  buildIdentifier: String
  sourceRevision: String
  artifactUri: String
  setupLogs: String
  buildLogs: String
  pushLogs: String
}

input BuildJobWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  completedAt: DateTime
  completedAt_not: DateTime
  completedAt_in: [DateTime!]
  completedAt_not_in: [DateTime!]
  completedAt_lt: DateTime
  completedAt_lte: DateTime
  completedAt_gt: DateTime
  completedAt_gte: DateTime
  buildHostKind: BuildHost
  buildHostKind_not: BuildHost
  buildHostKind_in: [BuildHost!]
  buildHostKind_not_in: [BuildHost!]
  buildHostIdentifier: String
  buildHostIdentifier_not: String
  buildHostIdentifier_in: [String!]
  buildHostIdentifier_not_in: [String!]
  buildHostIdentifier_lt: String
  buildHostIdentifier_lte: String
  buildHostIdentifier_gt: String
  buildHostIdentifier_gte: String
  buildHostIdentifier_contains: String
  buildHostIdentifier_not_contains: String
  buildHostIdentifier_starts_with: String
  buildHostIdentifier_not_starts_with: String
  buildHostIdentifier_ends_with: String
  buildHostIdentifier_not_ends_with: String
  repo: SourceRepositoryWhereInput
  status: BuildJobStatus
  status_not: BuildJobStatus
  status_in: [BuildJobStatus!]
  status_not_in: [BuildJobStatus!]
  buildIdentifier: String
  buildIdentifier_not: String
  buildIdentifier_in: [String!]
  buildIdentifier_not_in: [String!]
  buildIdentifier_lt: String
  buildIdentifier_lte: String
  buildIdentifier_gt: String
  buildIdentifier_gte: String
  buildIdentifier_contains: String
  buildIdentifier_not_contains: String
  buildIdentifier_starts_with: String
  buildIdentifier_not_starts_with: String
  buildIdentifier_ends_with: String
  buildIdentifier_not_ends_with: String
  sourceRevision: String
  sourceRevision_not: String
  sourceRevision_in: [String!]
  sourceRevision_not_in: [String!]
  sourceRevision_lt: String
  sourceRevision_lte: String
  sourceRevision_gt: String
  sourceRevision_gte: String
  sourceRevision_contains: String
  sourceRevision_not_contains: String
  sourceRevision_starts_with: String
  sourceRevision_not_starts_with: String
  sourceRevision_ends_with: String
  sourceRevision_not_ends_with: String
  artifactUri: String
  artifactUri_not: String
  artifactUri_in: [String!]
  artifactUri_not_in: [String!]
  artifactUri_lt: String
  artifactUri_lte: String
  artifactUri_gt: String
  artifactUri_gte: String
  artifactUri_contains: String
  artifactUri_not_contains: String
  artifactUri_starts_with: String
  artifactUri_not_starts_with: String
  artifactUri_ends_with: String
  artifactUri_not_ends_with: String
  setupLogs: String
  setupLogs_not: String
  setupLogs_in: [String!]
  setupLogs_not_in: [String!]
  setupLogs_lt: String
  setupLogs_lte: String
  setupLogs_gt: String
  setupLogs_gte: String
  setupLogs_contains: String
  setupLogs_not_contains: String
  setupLogs_starts_with: String
  setupLogs_not_starts_with: String
  setupLogs_ends_with: String
  setupLogs_not_ends_with: String
  buildLogs: String
  buildLogs_not: String
  buildLogs_in: [String!]
  buildLogs_not_in: [String!]
  buildLogs_lt: String
  buildLogs_lte: String
  buildLogs_gt: String
  buildLogs_gte: String
  buildLogs_contains: String
  buildLogs_not_contains: String
  buildLogs_starts_with: String
  buildLogs_not_starts_with: String
  buildLogs_ends_with: String
  buildLogs_not_ends_with: String
  pushLogs: String
  pushLogs_not: String
  pushLogs_in: [String!]
  pushLogs_not_in: [String!]
  pushLogs_lt: String
  pushLogs_lte: String
  pushLogs_gt: String
  pushLogs_gte: String
  pushLogs_contains: String
  pushLogs_not_contains: String
  pushLogs_starts_with: String
  pushLogs_not_starts_with: String
  pushLogs_ends_with: String
  pushLogs_not_ends_with: String
  AND: [BuildJobWhereInput!]
  OR: [BuildJobWhereInput!]
  NOT: [BuildJobWhereInput!]
}

input BuildJobWhereUniqueInput {
  id: ID
}

enum CloneStrategy {
  GIT_SSH
  GIT_HTTPS
}

scalar DateTime

type DockerRegistry {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  Hostname: String!
  AuthUsername: String!
  AuthPassword: String!
}

type DockerRegistryConnection {
  pageInfo: PageInfo!
  edges: [DockerRegistryEdge]!
  aggregate: AggregateDockerRegistry!
}

input DockerRegistryCreateInput {
  id: ID
  Hostname: String!
  AuthUsername: String!
  AuthPassword: String!
}

type DockerRegistryEdge {
  node: DockerRegistry!
  cursor: String!
}

enum DockerRegistryOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  Hostname_ASC
  Hostname_DESC
  AuthUsername_ASC
  AuthUsername_DESC
  AuthPassword_ASC
  AuthPassword_DESC
}

type DockerRegistryPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  Hostname: String!
  AuthUsername: String!
  AuthPassword: String!
}

type DockerRegistrySubscriptionPayload {
  mutation: MutationType!
  node: DockerRegistry
  updatedFields: [String!]
  previousValues: DockerRegistryPreviousValues
}

input DockerRegistrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DockerRegistryWhereInput
  AND: [DockerRegistrySubscriptionWhereInput!]
  OR: [DockerRegistrySubscriptionWhereInput!]
  NOT: [DockerRegistrySubscriptionWhereInput!]
}

input DockerRegistryUpdateInput {
  Hostname: String
  AuthUsername: String
  AuthPassword: String
}

input DockerRegistryUpdateManyMutationInput {
  Hostname: String
  AuthUsername: String
  AuthPassword: String
}

input DockerRegistryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  Hostname: String
  Hostname_not: String
  Hostname_in: [String!]
  Hostname_not_in: [String!]
  Hostname_lt: String
  Hostname_lte: String
  Hostname_gt: String
  Hostname_gte: String
  Hostname_contains: String
  Hostname_not_contains: String
  Hostname_starts_with: String
  Hostname_not_starts_with: String
  Hostname_ends_with: String
  Hostname_not_ends_with: String
  AuthUsername: String
  AuthUsername_not: String
  AuthUsername_in: [String!]
  AuthUsername_not_in: [String!]
  AuthUsername_lt: String
  AuthUsername_lte: String
  AuthUsername_gt: String
  AuthUsername_gte: String
  AuthUsername_contains: String
  AuthUsername_not_contains: String
  AuthUsername_starts_with: String
  AuthUsername_not_starts_with: String
  AuthUsername_ends_with: String
  AuthUsername_not_ends_with: String
  AuthPassword: String
  AuthPassword_not: String
  AuthPassword_in: [String!]
  AuthPassword_not_in: [String!]
  AuthPassword_lt: String
  AuthPassword_lte: String
  AuthPassword_gt: String
  AuthPassword_gte: String
  AuthPassword_contains: String
  AuthPassword_not_contains: String
  AuthPassword_starts_with: String
  AuthPassword_not_starts_with: String
  AuthPassword_ends_with: String
  AuthPassword_not_ends_with: String
  AND: [DockerRegistryWhereInput!]
  OR: [DockerRegistryWhereInput!]
  NOT: [DockerRegistryWhereInput!]
}

input DockerRegistryWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createBuildJob(data: BuildJobCreateInput!): BuildJob!
  updateBuildJob(data: BuildJobUpdateInput!, where: BuildJobWhereUniqueInput!): BuildJob
  updateManyBuildJobs(data: BuildJobUpdateManyMutationInput!, where: BuildJobWhereInput): BatchPayload!
  upsertBuildJob(where: BuildJobWhereUniqueInput!, create: BuildJobCreateInput!, update: BuildJobUpdateInput!): BuildJob!
  deleteBuildJob(where: BuildJobWhereUniqueInput!): BuildJob
  deleteManyBuildJobs(where: BuildJobWhereInput): BatchPayload!
  createDockerRegistry(data: DockerRegistryCreateInput!): DockerRegistry!
  updateDockerRegistry(data: DockerRegistryUpdateInput!, where: DockerRegistryWhereUniqueInput!): DockerRegistry
  updateManyDockerRegistries(data: DockerRegistryUpdateManyMutationInput!, where: DockerRegistryWhereInput): BatchPayload!
  upsertDockerRegistry(where: DockerRegistryWhereUniqueInput!, create: DockerRegistryCreateInput!, update: DockerRegistryUpdateInput!): DockerRegistry!
  deleteDockerRegistry(where: DockerRegistryWhereUniqueInput!): DockerRegistry
  deleteManyDockerRegistries(where: DockerRegistryWhereInput): BatchPayload!
  createSourceRepository(data: SourceRepositoryCreateInput!): SourceRepository!
  updateSourceRepository(data: SourceRepositoryUpdateInput!, where: SourceRepositoryWhereUniqueInput!): SourceRepository
  updateManySourceRepositories(data: SourceRepositoryUpdateManyMutationInput!, where: SourceRepositoryWhereInput): BatchPayload!
  upsertSourceRepository(where: SourceRepositoryWhereUniqueInput!, create: SourceRepositoryCreateInput!, update: SourceRepositoryUpdateInput!): SourceRepository!
  deleteSourceRepository(where: SourceRepositoryWhereUniqueInput!): SourceRepository
  deleteManySourceRepositories(where: SourceRepositoryWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  buildJob(where: BuildJobWhereUniqueInput!): BuildJob
  buildJobs(where: BuildJobWhereInput, orderBy: BuildJobOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BuildJob]!
  buildJobsConnection(where: BuildJobWhereInput, orderBy: BuildJobOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BuildJobConnection!
  dockerRegistry(where: DockerRegistryWhereUniqueInput!): DockerRegistry
  dockerRegistries(where: DockerRegistryWhereInput, orderBy: DockerRegistryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DockerRegistry]!
  dockerRegistriesConnection(where: DockerRegistryWhereInput, orderBy: DockerRegistryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DockerRegistryConnection!
  sourceRepository(where: SourceRepositoryWhereUniqueInput!): SourceRepository
  sourceRepositories(where: SourceRepositoryWhereInput, orderBy: SourceRepositoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SourceRepository]!
  sourceRepositoriesConnection(where: SourceRepositoryWhereInput, orderBy: SourceRepositoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SourceRepositoryConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum SourceProvider {
  Github
}

type SourceRepository {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: User!
  sourceProvider: SourceProvider
  name: String!
  authClientID: String
  authSecret: String
  cloneStrategy: CloneStrategy!
  buildsEnabled: Boolean!
  baseConfigurationFileName: String!
}

type SourceRepositoryConnection {
  pageInfo: PageInfo!
  edges: [SourceRepositoryEdge]!
  aggregate: AggregateSourceRepository!
}

input SourceRepositoryCreateInput {
  id: ID
  owner: UserCreateOneInput!
  sourceProvider: SourceProvider
  name: String!
  authClientID: String
  authSecret: String
  cloneStrategy: CloneStrategy!
  buildsEnabled: Boolean
  baseConfigurationFileName: String
}

input SourceRepositoryCreateOneInput {
  create: SourceRepositoryCreateInput
  connect: SourceRepositoryWhereUniqueInput
}

type SourceRepositoryEdge {
  node: SourceRepository!
  cursor: String!
}

enum SourceRepositoryOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sourceProvider_ASC
  sourceProvider_DESC
  name_ASC
  name_DESC
  authClientID_ASC
  authClientID_DESC
  authSecret_ASC
  authSecret_DESC
  cloneStrategy_ASC
  cloneStrategy_DESC
  buildsEnabled_ASC
  buildsEnabled_DESC
  baseConfigurationFileName_ASC
  baseConfigurationFileName_DESC
}

type SourceRepositoryPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  sourceProvider: SourceProvider
  name: String!
  authClientID: String
  authSecret: String
  cloneStrategy: CloneStrategy!
  buildsEnabled: Boolean!
  baseConfigurationFileName: String!
}

type SourceRepositorySubscriptionPayload {
  mutation: MutationType!
  node: SourceRepository
  updatedFields: [String!]
  previousValues: SourceRepositoryPreviousValues
}

input SourceRepositorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SourceRepositoryWhereInput
  AND: [SourceRepositorySubscriptionWhereInput!]
  OR: [SourceRepositorySubscriptionWhereInput!]
  NOT: [SourceRepositorySubscriptionWhereInput!]
}

input SourceRepositoryUpdateDataInput {
  owner: UserUpdateOneRequiredInput
  sourceProvider: SourceProvider
  name: String
  authClientID: String
  authSecret: String
  cloneStrategy: CloneStrategy
  buildsEnabled: Boolean
  baseConfigurationFileName: String
}

input SourceRepositoryUpdateInput {
  owner: UserUpdateOneRequiredInput
  sourceProvider: SourceProvider
  name: String
  authClientID: String
  authSecret: String
  cloneStrategy: CloneStrategy
  buildsEnabled: Boolean
  baseConfigurationFileName: String
}

input SourceRepositoryUpdateManyMutationInput {
  sourceProvider: SourceProvider
  name: String
  authClientID: String
  authSecret: String
  cloneStrategy: CloneStrategy
  buildsEnabled: Boolean
  baseConfigurationFileName: String
}

input SourceRepositoryUpdateOneRequiredInput {
  create: SourceRepositoryCreateInput
  update: SourceRepositoryUpdateDataInput
  upsert: SourceRepositoryUpsertNestedInput
  connect: SourceRepositoryWhereUniqueInput
}

input SourceRepositoryUpsertNestedInput {
  update: SourceRepositoryUpdateDataInput!
  create: SourceRepositoryCreateInput!
}

input SourceRepositoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  owner: UserWhereInput
  sourceProvider: SourceProvider
  sourceProvider_not: SourceProvider
  sourceProvider_in: [SourceProvider!]
  sourceProvider_not_in: [SourceProvider!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  authClientID: String
  authClientID_not: String
  authClientID_in: [String!]
  authClientID_not_in: [String!]
  authClientID_lt: String
  authClientID_lte: String
  authClientID_gt: String
  authClientID_gte: String
  authClientID_contains: String
  authClientID_not_contains: String
  authClientID_starts_with: String
  authClientID_not_starts_with: String
  authClientID_ends_with: String
  authClientID_not_ends_with: String
  authSecret: String
  authSecret_not: String
  authSecret_in: [String!]
  authSecret_not_in: [String!]
  authSecret_lt: String
  authSecret_lte: String
  authSecret_gt: String
  authSecret_gte: String
  authSecret_contains: String
  authSecret_not_contains: String
  authSecret_starts_with: String
  authSecret_not_starts_with: String
  authSecret_ends_with: String
  authSecret_not_ends_with: String
  cloneStrategy: CloneStrategy
  cloneStrategy_not: CloneStrategy
  cloneStrategy_in: [CloneStrategy!]
  cloneStrategy_not_in: [CloneStrategy!]
  buildsEnabled: Boolean
  buildsEnabled_not: Boolean
  baseConfigurationFileName: String
  baseConfigurationFileName_not: String
  baseConfigurationFileName_in: [String!]
  baseConfigurationFileName_not_in: [String!]
  baseConfigurationFileName_lt: String
  baseConfigurationFileName_lte: String
  baseConfigurationFileName_gt: String
  baseConfigurationFileName_gte: String
  baseConfigurationFileName_contains: String
  baseConfigurationFileName_not_contains: String
  baseConfigurationFileName_starts_with: String
  baseConfigurationFileName_not_starts_with: String
  baseConfigurationFileName_ends_with: String
  baseConfigurationFileName_not_ends_with: String
  AND: [SourceRepositoryWhereInput!]
  OR: [SourceRepositoryWhereInput!]
  NOT: [SourceRepositoryWhereInput!]
}

input SourceRepositoryWhereUniqueInput {
  id: ID
}

type Subscription {
  buildJob(where: BuildJobSubscriptionWhereInput): BuildJobSubscriptionPayload
  dockerRegistry(where: DockerRegistrySubscriptionWhereInput): DockerRegistrySubscriptionPayload
  sourceRepository(where: SourceRepositorySubscriptionWhereInput): SourceRepositorySubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  email: String!
  passwordHash: String
  githubUsername: String
  githubAccountAuthToken: String
  googleAccountAuthToken: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  passwordHash: String
  githubUsername: String
  githubAccountAuthToken: String
  googleAccountAuthToken: String
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  passwordHash_ASC
  passwordHash_DESC
  githubUsername_ASC
  githubUsername_DESC
  githubAccountAuthToken_ASC
  githubAccountAuthToken_DESC
  googleAccountAuthToken_ASC
  googleAccountAuthToken_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  email: String!
  passwordHash: String
  githubUsername: String
  githubAccountAuthToken: String
  googleAccountAuthToken: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
  email: String
  passwordHash: String
  githubUsername: String
  githubAccountAuthToken: String
  googleAccountAuthToken: String
}

input UserUpdateInput {
  name: String
  email: String
  passwordHash: String
  githubUsername: String
  githubAccountAuthToken: String
  googleAccountAuthToken: String
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  passwordHash: String
  githubUsername: String
  githubAccountAuthToken: String
  googleAccountAuthToken: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  passwordHash: String
  passwordHash_not: String
  passwordHash_in: [String!]
  passwordHash_not_in: [String!]
  passwordHash_lt: String
  passwordHash_lte: String
  passwordHash_gt: String
  passwordHash_gte: String
  passwordHash_contains: String
  passwordHash_not_contains: String
  passwordHash_starts_with: String
  passwordHash_not_starts_with: String
  passwordHash_ends_with: String
  passwordHash_not_ends_with: String
  githubUsername: String
  githubUsername_not: String
  githubUsername_in: [String!]
  githubUsername_not_in: [String!]
  githubUsername_lt: String
  githubUsername_lte: String
  githubUsername_gt: String
  githubUsername_gte: String
  githubUsername_contains: String
  githubUsername_not_contains: String
  githubUsername_starts_with: String
  githubUsername_not_starts_with: String
  githubUsername_ends_with: String
  githubUsername_not_ends_with: String
  githubAccountAuthToken: String
  githubAccountAuthToken_not: String
  githubAccountAuthToken_in: [String!]
  githubAccountAuthToken_not_in: [String!]
  githubAccountAuthToken_lt: String
  githubAccountAuthToken_lte: String
  githubAccountAuthToken_gt: String
  githubAccountAuthToken_gte: String
  githubAccountAuthToken_contains: String
  githubAccountAuthToken_not_contains: String
  githubAccountAuthToken_starts_with: String
  githubAccountAuthToken_not_starts_with: String
  githubAccountAuthToken_ends_with: String
  githubAccountAuthToken_not_ends_with: String
  googleAccountAuthToken: String
  googleAccountAuthToken_not: String
  googleAccountAuthToken_in: [String!]
  googleAccountAuthToken_not_in: [String!]
  googleAccountAuthToken_lt: String
  googleAccountAuthToken_lte: String
  googleAccountAuthToken_gt: String
  googleAccountAuthToken_gte: String
  googleAccountAuthToken_contains: String
  googleAccountAuthToken_not_contains: String
  googleAccountAuthToken_starts_with: String
  googleAccountAuthToken_not_starts_with: String
  googleAccountAuthToken_ends_with: String
  googleAccountAuthToken_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createBuildJob_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.BuildJobCreateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNBuildJobCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createDockerRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.DockerRegistryCreateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNDockerRegistryCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSourceRepository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.SourceRepositoryCreateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNSourceRepositoryCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UserCreateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNUserCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteBuildJob_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.BuildJobWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNBuildJobWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDockerRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.DockerRegistryWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNDockerRegistryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteManyBuildJobs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.BuildJobWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOBuildJobWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteManyDockerRegistries_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.DockerRegistryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalODockerRegistryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteManySourceRepositories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.SourceRepositoryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOSourceRepositoryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteManyUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSourceRepository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.SourceRepositoryWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNSourceRepositoryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UserWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNUserWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateBuildJob_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.BuildJobUpdateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNBuildJobUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	var arg1 models.BuildJobWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg1, err = ec.unmarshalNBuildJobWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateDockerRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.DockerRegistryUpdateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNDockerRegistryUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	var arg1 models.DockerRegistryWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg1, err = ec.unmarshalNDockerRegistryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateManyBuildJobs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.BuildJobUpdateManyMutationInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNBuildJobUpdateManyMutationInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobUpdateManyMutationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	var arg1 *models.BuildJobWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg1, err = ec.unmarshalOBuildJobWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateManyDockerRegistries_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.DockerRegistryUpdateManyMutationInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNDockerRegistryUpdateManyMutationInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryUpdateManyMutationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	var arg1 *models.DockerRegistryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg1, err = ec.unmarshalODockerRegistryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateManySourceRepositories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.SourceRepositoryUpdateManyMutationInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNSourceRepositoryUpdateManyMutationInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateManyMutationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	var arg1 *models.SourceRepositoryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg1, err = ec.unmarshalOSourceRepositoryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateManyUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UserUpdateManyMutationInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNUserUpdateManyMutationInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateManyMutationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	var arg1 *models.UserWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg1, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSourceRepository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.SourceRepositoryUpdateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNSourceRepositoryUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	var arg1 models.SourceRepositoryWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg1, err = ec.unmarshalNSourceRepositoryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UserUpdateInput
	if tmp, ok := rawArgs["data"]; ok {
		arg0, err = ec.unmarshalNUserUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	var arg1 models.UserWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg1, err = ec.unmarshalNUserWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertBuildJob_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.BuildJobWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNBuildJobWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 models.BuildJobCreateInput
	if tmp, ok := rawArgs["create"]; ok {
		arg1, err = ec.unmarshalNBuildJobCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["create"] = arg1
	var arg2 models.BuildJobUpdateInput
	if tmp, ok := rawArgs["update"]; ok {
		arg2, err = ec.unmarshalNBuildJobUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["update"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertDockerRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.DockerRegistryWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNDockerRegistryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 models.DockerRegistryCreateInput
	if tmp, ok := rawArgs["create"]; ok {
		arg1, err = ec.unmarshalNDockerRegistryCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["create"] = arg1
	var arg2 models.DockerRegistryUpdateInput
	if tmp, ok := rawArgs["update"]; ok {
		arg2, err = ec.unmarshalNDockerRegistryUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["update"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertSourceRepository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.SourceRepositoryWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNSourceRepositoryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 models.SourceRepositoryCreateInput
	if tmp, ok := rawArgs["create"]; ok {
		arg1, err = ec.unmarshalNSourceRepositoryCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["create"] = arg1
	var arg2 models.SourceRepositoryUpdateInput
	if tmp, ok := rawArgs["update"]; ok {
		arg2, err = ec.unmarshalNSourceRepositoryUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["update"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UserWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNUserWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 models.UserCreateInput
	if tmp, ok := rawArgs["create"]; ok {
		arg1, err = ec.unmarshalNUserCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["create"] = arg1
	var arg2 models.UserUpdateInput
	if tmp, ok := rawArgs["update"]; ok {
		arg2, err = ec.unmarshalNUserUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["update"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_buildJob_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.BuildJobWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNBuildJobWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_buildJobsConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.BuildJobWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOBuildJobWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *models.BuildJobOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOBuildJobOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_buildJobs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.BuildJobWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOBuildJobWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *models.BuildJobOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOBuildJobOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_dockerRegistriesConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.DockerRegistryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalODockerRegistryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *models.DockerRegistryOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalODockerRegistryOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_dockerRegistries_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.DockerRegistryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalODockerRegistryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *models.DockerRegistryOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalODockerRegistryOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_dockerRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.DockerRegistryWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNDockerRegistryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_sourceRepositoriesConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.SourceRepositoryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOSourceRepositoryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *models.SourceRepositoryOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOSourceRepositoryOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_sourceRepositories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.SourceRepositoryWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOSourceRepositoryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *models.SourceRepositoryOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOSourceRepositoryOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_sourceRepository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.SourceRepositoryWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNSourceRepositoryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UserWhereUniqueInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalNUserWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereUniqueInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_usersConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *models.UserOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOUserOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *models.UserOrderByInput
	if tmp, ok := rawArgs["orderBy"]; ok {
		arg1, err = ec.unmarshalOUserOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserOrderByInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["skip"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["skip"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["first"]; ok {
		arg5, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg5
	var arg6 *int
	if tmp, ok := rawArgs["last"]; ok {
		arg6, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg6
	return args, nil
}

func (ec *executionContext) field_Subscription_buildJob_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.BuildJobSubscriptionWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOBuildJobSubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_dockerRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.DockerRegistrySubscriptionWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalODockerRegistrySubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_sourceRepository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.SourceRepositorySubscriptionWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOSourceRepositorySubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserSubscriptionWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		arg0, err = ec.unmarshalOUserSubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AggregateBuildJob_count(ctx context.Context, field graphql.CollectedField, obj *models.AggregateBuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AggregateBuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AggregateDockerRegistry_count(ctx context.Context, field graphql.CollectedField, obj *models.AggregateDockerRegistry) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AggregateDockerRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AggregateSourceRepository_count(ctx context.Context, field graphql.CollectedField, obj *models.AggregateSourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AggregateSourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AggregateUser_count(ctx context.Context, field graphql.CollectedField, obj *models.AggregateUser) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AggregateUser",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _BatchPayload_count(ctx context.Context, field graphql.CollectedField, obj *models.BatchPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BatchPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLong2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_id(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_completedAt(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_buildHostKind(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildHostKind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.BuildHost)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBuildHost2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_buildHostIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildHostIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_repo(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SourceRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_status(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.BuildJobStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBuildJobStatus2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_buildIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_sourceRevision(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_artifactUri(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArtifactURI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_setupLogs(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetupLogs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_buildLogs(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildLogs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJob_pushLogs(ctx context.Context, field graphql.CollectedField, obj *models.BuildJob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PushLogs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PageInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobConnection_edges(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.BuildJobEdge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBuildJobEdge2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobEdge(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobConnection_aggregate(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.AggregateBuildJob)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAggregateBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateBuildJob(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobEdge_node(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobEdge) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobEdge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BuildJob)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobEdge) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobEdge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_id(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_completedAt(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_buildHostKind(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildHostKind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.BuildHost)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBuildHost2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_buildHostIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildHostIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_status(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.BuildJobStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBuildJobStatus2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_buildIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_sourceRevision(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_artifactUri(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArtifactURI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_setupLogs(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetupLogs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_buildLogs(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildLogs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobPreviousValues_pushLogs(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PushLogs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobSubscriptionPayload_mutation(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobSubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobSubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mutation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MutationType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMutationType2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobSubscriptionPayload_node(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobSubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobSubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.BuildJob)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobSubscriptionPayload_updatedFields(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobSubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobSubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _BuildJobSubscriptionPayload_previousValues(ctx context.Context, field graphql.CollectedField, obj *models.BuildJobSubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BuildJobSubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousValues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.BuildJobPreviousValues)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBuildJobPreviousValues2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobPreviousValues(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistry_id(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistry) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistry_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistry) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistry_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistry) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistry_Hostname(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistry) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistry_AuthUsername(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistry) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistry_AuthPassword(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistry) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthPassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistryConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistryConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistryConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PageInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistryConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistryConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.DockerRegistryEdge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDockerRegistryEdge2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryEdge(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistryConnection_aggregate(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistryConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistryConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.AggregateDockerRegistry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAggregateDockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateDockerRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistryEdge_node(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistryEdge) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistryEdge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.DockerRegistry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistryEdge) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistryEdge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistryPreviousValues_id(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistryPreviousValues_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistryPreviousValues_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistryPreviousValues_Hostname(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistryPreviousValues_AuthUsername(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistryPreviousValues_AuthPassword(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthPassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistrySubscriptionPayload_mutation(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistrySubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistrySubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mutation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MutationType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMutationType2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistrySubscriptionPayload_node(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistrySubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistrySubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.DockerRegistry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistrySubscriptionPayload_updatedFields(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistrySubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistrySubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DockerRegistrySubscriptionPayload_previousValues(ctx context.Context, field graphql.CollectedField, obj *models.DockerRegistrySubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DockerRegistrySubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousValues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.DockerRegistryPreviousValues)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODockerRegistryPreviousValues2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryPreviousValues(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createBuildJob(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createBuildJob_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateBuildJob(rctx, args["data"].(models.BuildJobCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BuildJob)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateBuildJob(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateBuildJob_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateBuildJob(rctx, args["data"].(models.BuildJobUpdateInput), args["where"].(models.BuildJobWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.BuildJob)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateManyBuildJobs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateManyBuildJobs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateManyBuildJobs(rctx, args["data"].(models.BuildJobUpdateManyMutationInput), args["where"].(*models.BuildJobWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BatchPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBatchPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBatchPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_upsertBuildJob(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_upsertBuildJob_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertBuildJob(rctx, args["where"].(models.BuildJobWhereUniqueInput), args["create"].(models.BuildJobCreateInput), args["update"].(models.BuildJobUpdateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BuildJob)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteBuildJob(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteBuildJob_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteBuildJob(rctx, args["where"].(models.BuildJobWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.BuildJob)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteManyBuildJobs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteManyBuildJobs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteManyBuildJobs(rctx, args["where"].(*models.BuildJobWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BatchPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBatchPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBatchPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createDockerRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createDockerRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateDockerRegistry(rctx, args["data"].(models.DockerRegistryCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.DockerRegistry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateDockerRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateDockerRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateDockerRegistry(rctx, args["data"].(models.DockerRegistryUpdateInput), args["where"].(models.DockerRegistryWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.DockerRegistry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateManyDockerRegistries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateManyDockerRegistries_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateManyDockerRegistries(rctx, args["data"].(models.DockerRegistryUpdateManyMutationInput), args["where"].(*models.DockerRegistryWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BatchPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBatchPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBatchPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_upsertDockerRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_upsertDockerRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertDockerRegistry(rctx, args["where"].(models.DockerRegistryWhereUniqueInput), args["create"].(models.DockerRegistryCreateInput), args["update"].(models.DockerRegistryUpdateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.DockerRegistry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteDockerRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteDockerRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteDockerRegistry(rctx, args["where"].(models.DockerRegistryWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.DockerRegistry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteManyDockerRegistries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteManyDockerRegistries_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteManyDockerRegistries(rctx, args["where"].(*models.DockerRegistryWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BatchPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBatchPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBatchPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createSourceRepository(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createSourceRepository_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateSourceRepository(rctx, args["data"].(models.SourceRepositoryCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SourceRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateSourceRepository(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateSourceRepository_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateSourceRepository(rctx, args["data"].(models.SourceRepositoryUpdateInput), args["where"].(models.SourceRepositoryWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SourceRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateManySourceRepositories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateManySourceRepositories_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateManySourceRepositories(rctx, args["data"].(models.SourceRepositoryUpdateManyMutationInput), args["where"].(*models.SourceRepositoryWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BatchPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBatchPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBatchPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_upsertSourceRepository(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_upsertSourceRepository_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertSourceRepository(rctx, args["where"].(models.SourceRepositoryWhereUniqueInput), args["create"].(models.SourceRepositoryCreateInput), args["update"].(models.SourceRepositoryUpdateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SourceRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteSourceRepository(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteSourceRepository_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteSourceRepository(rctx, args["where"].(models.SourceRepositoryWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SourceRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteManySourceRepositories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteManySourceRepositories_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteManySourceRepositories(rctx, args["where"].(*models.SourceRepositoryWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BatchPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBatchPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBatchPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, args["data"].(models.UserCreateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUser(rctx, args["data"].(models.UserUpdateInput), args["where"].(models.UserWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateManyUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateManyUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateManyUsers(rctx, args["data"].(models.UserUpdateManyMutationInput), args["where"].(*models.UserWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BatchPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBatchPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBatchPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_upsertUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_upsertUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertUser(rctx, args["where"].(models.UserWhereUniqueInput), args["create"].(models.UserCreateInput), args["update"].(models.UserUpdateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteUser(rctx, args["where"].(models.UserWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteManyUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteManyUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteManyUsers(rctx, args["where"].(*models.UserWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BatchPayload)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBatchPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBatchPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PageInfo",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PageInfo",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PageInfo",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *models.PageInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PageInfo",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_buildJob(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_buildJob_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BuildJob(rctx, args["where"].(models.BuildJobWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.BuildJob)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_buildJobs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_buildJobs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BuildJobs(rctx, args["where"].(*models.BuildJobWhereInput), args["orderBy"].(*models.BuildJobOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.BuildJob)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBuildJob2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_buildJobsConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_buildJobsConnection_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BuildJobsConnection(rctx, args["where"].(*models.BuildJobWhereInput), args["orderBy"].(*models.BuildJobOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BuildJobConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBuildJobConnection2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobConnection(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_dockerRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_dockerRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DockerRegistry(rctx, args["where"].(models.DockerRegistryWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.DockerRegistry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_dockerRegistries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_dockerRegistries_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DockerRegistries(rctx, args["where"].(*models.DockerRegistryWhereInput), args["orderBy"].(*models.DockerRegistryOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.DockerRegistry)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDockerRegistry2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_dockerRegistriesConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_dockerRegistriesConnection_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DockerRegistriesConnection(rctx, args["where"].(*models.DockerRegistryWhereInput), args["orderBy"].(*models.DockerRegistryOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.DockerRegistryConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDockerRegistryConnection2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryConnection(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_sourceRepository(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_sourceRepository_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SourceRepository(rctx, args["where"].(models.SourceRepositoryWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SourceRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_sourceRepositories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_sourceRepositories_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SourceRepositories(rctx, args["where"].(*models.SourceRepositoryWhereInput), args["orderBy"].(*models.SourceRepositoryOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.SourceRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSourceRepository2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_sourceRepositoriesConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_sourceRepositoriesConnection_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SourceRepositoriesConnection(rctx, args["where"].(*models.SourceRepositoryWhereInput), args["orderBy"].(*models.SourceRepositoryOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SourceRepositoryConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSourceRepositoryConnection2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryConnection(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_user_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, args["where"].(models.UserWhereUniqueInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_users_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx, args["where"].(*models.UserWhereInput), args["orderBy"].(*models.UserOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_usersConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_usersConnection_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UsersConnection(rctx, args["where"].(*models.UserWhereInput), args["orderBy"].(*models.UserOrderByInput), args["skip"].(*int), args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.UserConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUserConnection2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserConnection(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_node_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Node)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalONode2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐNode(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepository_id(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepository_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepository_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepository_owner(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepository_sourceProvider(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceProvider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SourceProvider)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOSourceProvider2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepository_name(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepository_authClientID(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthClientID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepository_authSecret(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthSecret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepository_cloneStrategy(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloneStrategy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.CloneStrategy)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCloneStrategy2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepository_buildsEnabled(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildsEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepository_baseConfigurationFileName(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseConfigurationFileName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PageInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryConnection_edges(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.SourceRepositoryEdge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSourceRepositoryEdge2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryEdge(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryConnection_aggregate(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.AggregateSourceRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAggregateSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateSourceRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryEdge_node(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryEdge) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryEdge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SourceRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryEdge) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryEdge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryPreviousValues_id(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryPreviousValues_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryPreviousValues_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryPreviousValues_sourceProvider(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceProvider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SourceProvider)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOSourceProvider2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryPreviousValues_name(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryPreviousValues_authClientID(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthClientID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryPreviousValues_authSecret(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthSecret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryPreviousValues_cloneStrategy(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloneStrategy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.CloneStrategy)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCloneStrategy2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryPreviousValues_buildsEnabled(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildsEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositoryPreviousValues_baseConfigurationFileName(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositoryPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositoryPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseConfigurationFileName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositorySubscriptionPayload_mutation(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositorySubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositorySubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mutation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MutationType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMutationType2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositorySubscriptionPayload_node(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositorySubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositorySubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SourceRepository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositorySubscriptionPayload_updatedFields(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositorySubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositorySubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _SourceRepositorySubscriptionPayload_previousValues(ctx context.Context, field graphql.CollectedField, obj *models.SourceRepositorySubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "SourceRepositorySubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousValues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SourceRepositoryPreviousValues)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOSourceRepositoryPreviousValues2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryPreviousValues(ctx, field.Selections, res)
}

func (ec *executionContext) _Subscription_buildJob(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
		Args:  nil,
	})
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_buildJob_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().BuildJob(rctx, args["where"].(*models.BuildJobSubscriptionWhereInput))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalOBuildJobSubscriptionPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionPayload(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_dockerRegistry(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
		Args:  nil,
	})
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_dockerRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().DockerRegistry(rctx, args["where"].(*models.DockerRegistrySubscriptionWhereInput))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalODockerRegistrySubscriptionPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionPayload(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_sourceRepository(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
		Args:  nil,
	})
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_sourceRepository_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().SourceRepository(rctx, args["where"].(*models.SourceRepositorySubscriptionWhereInput))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalOSourceRepositorySubscriptionPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionPayload(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_user(ctx context.Context, field graphql.CollectedField) func() graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Field: field,
		Args:  nil,
	})
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_user_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	// FIXME: subscriptions are missing request middleware stack https://github.com/99designs/gqlgen/issues/259
	//          and Tracer stack
	rctx := ctx
	results, err := ec.resolvers.Subscription().User(rctx, args["where"].(*models.UserSubscriptionWhereInput))
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-results
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalOUserSubscriptionPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionPayload(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_passwordHash(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PasswordHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _User_githubUsername(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _User_githubAccountAuthToken(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubAccountAuthToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _User_googleAccountAuthToken(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoogleAccountAuthToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _UserConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *models.UserConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PageInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _UserConnection_edges(ctx context.Context, field graphql.CollectedField, obj *models.UserConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.UserEdge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUserEdge2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserEdge(ctx, field.Selections, res)
}

func (ec *executionContext) _UserConnection_aggregate(ctx context.Context, field graphql.CollectedField, obj *models.UserConnection) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserConnection",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aggregate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.AggregateUser)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAggregateUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateUser(ctx, field.Selections, res)
}

func (ec *executionContext) _UserEdge_node(ctx context.Context, field graphql.CollectedField, obj *models.UserEdge) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserEdge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _UserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *models.UserEdge) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserEdge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserPreviousValues_id(ctx context.Context, field graphql.CollectedField, obj *models.UserPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserPreviousValues_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.UserPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserPreviousValues_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.UserPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserPreviousValues_name(ctx context.Context, field graphql.CollectedField, obj *models.UserPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserPreviousValues_email(ctx context.Context, field graphql.CollectedField, obj *models.UserPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserPreviousValues_passwordHash(ctx context.Context, field graphql.CollectedField, obj *models.UserPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PasswordHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _UserPreviousValues_githubUsername(ctx context.Context, field graphql.CollectedField, obj *models.UserPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _UserPreviousValues_githubAccountAuthToken(ctx context.Context, field graphql.CollectedField, obj *models.UserPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubAccountAuthToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _UserPreviousValues_googleAccountAuthToken(ctx context.Context, field graphql.CollectedField, obj *models.UserPreviousValues) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserPreviousValues",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoogleAccountAuthToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _UserSubscriptionPayload_mutation(ctx context.Context, field graphql.CollectedField, obj *models.UserSubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserSubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mutation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MutationType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMutationType2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx, field.Selections, res)
}

func (ec *executionContext) _UserSubscriptionPayload_node(ctx context.Context, field graphql.CollectedField, obj *models.UserSubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserSubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _UserSubscriptionPayload_updatedFields(ctx context.Context, field graphql.CollectedField, obj *models.UserSubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserSubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _UserSubscriptionPayload_previousValues(ctx context.Context, field graphql.CollectedField, obj *models.UserSubscriptionPayload) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserSubscriptionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousValues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.UserPreviousValues)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUserPreviousValues2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserPreviousValues(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputBuildJobCreateInput(ctx context.Context, obj interface{}) (models.BuildJobCreateInput, error) {
	var it models.BuildJobCreateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "completedAt":
			var err error
			it.CompletedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostKind":
			var err error
			it.BuildHostKind, err = ec.unmarshalNBuildHost2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier":
			var err error
			it.BuildHostIdentifier, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "repo":
			var err error
			it.Repo, err = ec.unmarshalNSourceRepositoryCreateOneInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateOneInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "status":
			var err error
			it.Status, err = ec.unmarshalNBuildJobStatus2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier":
			var err error
			it.BuildIdentifier, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision":
			var err error
			it.SourceRevision, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri":
			var err error
			it.ArtifactURI, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs":
			var err error
			it.SetupLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs":
			var err error
			it.BuildLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs":
			var err error
			it.PushLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildJobSubscriptionWhereInput(ctx context.Context, obj interface{}) (models.BuildJobSubscriptionWhereInput, error) {
	var it models.BuildJobSubscriptionWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "mutation_in":
			var err error
			it.MutationIn, err = ec.unmarshalOMutationType2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains":
			var err error
			it.UpdatedFieldsContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains_every":
			var err error
			it.UpdatedFieldsContainsEvery, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains_some":
			var err error
			it.UpdatedFieldsContainsSome, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "node":
			var err error
			it.Node, err = ec.unmarshalOBuildJobWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOBuildJobSubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOBuildJobSubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOBuildJobSubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildJobUpdateInput(ctx context.Context, obj interface{}) (models.BuildJobUpdateInput, error) {
	var it models.BuildJobUpdateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "completedAt":
			var err error
			it.CompletedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostKind":
			var err error
			it.BuildHostKind, err = ec.unmarshalOBuildHost2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier":
			var err error
			it.BuildHostIdentifier, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "repo":
			var err error
			it.Repo, err = ec.unmarshalOSourceRepositoryUpdateOneRequiredInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateOneRequiredInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "status":
			var err error
			it.Status, err = ec.unmarshalOBuildJobStatus2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier":
			var err error
			it.BuildIdentifier, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision":
			var err error
			it.SourceRevision, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri":
			var err error
			it.ArtifactURI, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs":
			var err error
			it.SetupLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs":
			var err error
			it.BuildLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs":
			var err error
			it.PushLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildJobUpdateManyMutationInput(ctx context.Context, obj interface{}) (models.BuildJobUpdateManyMutationInput, error) {
	var it models.BuildJobUpdateManyMutationInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "completedAt":
			var err error
			it.CompletedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostKind":
			var err error
			it.BuildHostKind, err = ec.unmarshalOBuildHost2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier":
			var err error
			it.BuildHostIdentifier, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "status":
			var err error
			it.Status, err = ec.unmarshalOBuildJobStatus2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier":
			var err error
			it.BuildIdentifier, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision":
			var err error
			it.SourceRevision, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri":
			var err error
			it.ArtifactURI, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs":
			var err error
			it.SetupLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs":
			var err error
			it.BuildLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs":
			var err error
			it.PushLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildJobWhereInput(ctx context.Context, obj interface{}) (models.BuildJobWhereInput, error) {
	var it models.BuildJobWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not":
			var err error
			it.IDNot, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_contains":
			var err error
			it.IDContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_contains":
			var err error
			it.IDNotContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_starts_with":
			var err error
			it.IDStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_starts_with":
			var err error
			it.IDNotStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ends_with":
			var err error
			it.IDEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_ends_with":
			var err error
			it.IDNotEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not":
			var err error
			it.CreatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_in":
			var err error
			it.CreatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not_in":
			var err error
			it.CreatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lt":
			var err error
			it.CreatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lte":
			var err error
			it.CreatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gt":
			var err error
			it.CreatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gte":
			var err error
			it.CreatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error
			it.UpdatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_not":
			var err error
			it.UpdatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_in":
			var err error
			it.UpdatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_not_in":
			var err error
			it.UpdatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lt":
			var err error
			it.UpdatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lte":
			var err error
			it.UpdatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gt":
			var err error
			it.UpdatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gte":
			var err error
			it.UpdatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "completedAt":
			var err error
			it.CompletedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "completedAt_not":
			var err error
			it.CompletedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "completedAt_in":
			var err error
			it.CompletedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "completedAt_not_in":
			var err error
			it.CompletedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "completedAt_lt":
			var err error
			it.CompletedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "completedAt_lte":
			var err error
			it.CompletedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "completedAt_gt":
			var err error
			it.CompletedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "completedAt_gte":
			var err error
			it.CompletedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostKind":
			var err error
			it.BuildHostKind, err = ec.unmarshalOBuildHost2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostKind_not":
			var err error
			it.BuildHostKindNot, err = ec.unmarshalOBuildHost2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostKind_in":
			var err error
			it.BuildHostKindIn, err = ec.unmarshalOBuildHost2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostKind_not_in":
			var err error
			it.BuildHostKindNotIn, err = ec.unmarshalOBuildHost2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier":
			var err error
			it.BuildHostIdentifier, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_not":
			var err error
			it.BuildHostIdentifierNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_in":
			var err error
			it.BuildHostIdentifierIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_not_in":
			var err error
			it.BuildHostIdentifierNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_lt":
			var err error
			it.BuildHostIdentifierLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_lte":
			var err error
			it.BuildHostIdentifierLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_gt":
			var err error
			it.BuildHostIdentifierGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_gte":
			var err error
			it.BuildHostIdentifierGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_contains":
			var err error
			it.BuildHostIdentifierContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_not_contains":
			var err error
			it.BuildHostIdentifierNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_starts_with":
			var err error
			it.BuildHostIdentifierStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_not_starts_with":
			var err error
			it.BuildHostIdentifierNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_ends_with":
			var err error
			it.BuildHostIdentifierEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildHostIdentifier_not_ends_with":
			var err error
			it.BuildHostIdentifierNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "repo":
			var err error
			it.Repo, err = ec.unmarshalOSourceRepositoryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "status":
			var err error
			it.Status, err = ec.unmarshalOBuildJobStatus2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "status_not":
			var err error
			it.StatusNot, err = ec.unmarshalOBuildJobStatus2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "status_in":
			var err error
			it.StatusIn, err = ec.unmarshalOBuildJobStatus2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "status_not_in":
			var err error
			it.StatusNotIn, err = ec.unmarshalOBuildJobStatus2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier":
			var err error
			it.BuildIdentifier, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_not":
			var err error
			it.BuildIdentifierNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_in":
			var err error
			it.BuildIdentifierIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_not_in":
			var err error
			it.BuildIdentifierNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_lt":
			var err error
			it.BuildIdentifierLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_lte":
			var err error
			it.BuildIdentifierLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_gt":
			var err error
			it.BuildIdentifierGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_gte":
			var err error
			it.BuildIdentifierGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_contains":
			var err error
			it.BuildIdentifierContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_not_contains":
			var err error
			it.BuildIdentifierNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_starts_with":
			var err error
			it.BuildIdentifierStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_not_starts_with":
			var err error
			it.BuildIdentifierNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_ends_with":
			var err error
			it.BuildIdentifierEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildIdentifier_not_ends_with":
			var err error
			it.BuildIdentifierNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision":
			var err error
			it.SourceRevision, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_not":
			var err error
			it.SourceRevisionNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_in":
			var err error
			it.SourceRevisionIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_not_in":
			var err error
			it.SourceRevisionNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_lt":
			var err error
			it.SourceRevisionLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_lte":
			var err error
			it.SourceRevisionLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_gt":
			var err error
			it.SourceRevisionGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_gte":
			var err error
			it.SourceRevisionGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_contains":
			var err error
			it.SourceRevisionContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_not_contains":
			var err error
			it.SourceRevisionNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_starts_with":
			var err error
			it.SourceRevisionStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_not_starts_with":
			var err error
			it.SourceRevisionNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_ends_with":
			var err error
			it.SourceRevisionEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceRevision_not_ends_with":
			var err error
			it.SourceRevisionNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri":
			var err error
			it.ArtifactURI, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_not":
			var err error
			it.ArtifactURINot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_in":
			var err error
			it.ArtifactURIIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_not_in":
			var err error
			it.ArtifactURINotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_lt":
			var err error
			it.ArtifactURILt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_lte":
			var err error
			it.ArtifactURILte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_gt":
			var err error
			it.ArtifactURIGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_gte":
			var err error
			it.ArtifactURIGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_contains":
			var err error
			it.ArtifactURIContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_not_contains":
			var err error
			it.ArtifactURINotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_starts_with":
			var err error
			it.ArtifactURIStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_not_starts_with":
			var err error
			it.ArtifactURINotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_ends_with":
			var err error
			it.ArtifactURIEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "artifactUri_not_ends_with":
			var err error
			it.ArtifactURINotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs":
			var err error
			it.SetupLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_not":
			var err error
			it.SetupLogsNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_in":
			var err error
			it.SetupLogsIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_not_in":
			var err error
			it.SetupLogsNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_lt":
			var err error
			it.SetupLogsLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_lte":
			var err error
			it.SetupLogsLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_gt":
			var err error
			it.SetupLogsGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_gte":
			var err error
			it.SetupLogsGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_contains":
			var err error
			it.SetupLogsContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_not_contains":
			var err error
			it.SetupLogsNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_starts_with":
			var err error
			it.SetupLogsStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_not_starts_with":
			var err error
			it.SetupLogsNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_ends_with":
			var err error
			it.SetupLogsEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "setupLogs_not_ends_with":
			var err error
			it.SetupLogsNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs":
			var err error
			it.BuildLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_not":
			var err error
			it.BuildLogsNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_in":
			var err error
			it.BuildLogsIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_not_in":
			var err error
			it.BuildLogsNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_lt":
			var err error
			it.BuildLogsLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_lte":
			var err error
			it.BuildLogsLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_gt":
			var err error
			it.BuildLogsGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_gte":
			var err error
			it.BuildLogsGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_contains":
			var err error
			it.BuildLogsContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_not_contains":
			var err error
			it.BuildLogsNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_starts_with":
			var err error
			it.BuildLogsStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_not_starts_with":
			var err error
			it.BuildLogsNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_ends_with":
			var err error
			it.BuildLogsEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildLogs_not_ends_with":
			var err error
			it.BuildLogsNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs":
			var err error
			it.PushLogs, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_not":
			var err error
			it.PushLogsNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_in":
			var err error
			it.PushLogsIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_not_in":
			var err error
			it.PushLogsNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_lt":
			var err error
			it.PushLogsLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_lte":
			var err error
			it.PushLogsLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_gt":
			var err error
			it.PushLogsGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_gte":
			var err error
			it.PushLogsGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_contains":
			var err error
			it.PushLogsContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_not_contains":
			var err error
			it.PushLogsNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_starts_with":
			var err error
			it.PushLogsStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_not_starts_with":
			var err error
			it.PushLogsNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_ends_with":
			var err error
			it.PushLogsEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pushLogs_not_ends_with":
			var err error
			it.PushLogsNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOBuildJobWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOBuildJobWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOBuildJobWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildJobWhereUniqueInput(ctx context.Context, obj interface{}) (models.BuildJobWhereUniqueInput, error) {
	var it models.BuildJobWhereUniqueInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDockerRegistryCreateInput(ctx context.Context, obj interface{}) (models.DockerRegistryCreateInput, error) {
	var it models.DockerRegistryCreateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname":
			var err error
			it.Hostname, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername":
			var err error
			it.AuthUsername, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword":
			var err error
			it.AuthPassword, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDockerRegistrySubscriptionWhereInput(ctx context.Context, obj interface{}) (models.DockerRegistrySubscriptionWhereInput, error) {
	var it models.DockerRegistrySubscriptionWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "mutation_in":
			var err error
			it.MutationIn, err = ec.unmarshalOMutationType2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains":
			var err error
			it.UpdatedFieldsContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains_every":
			var err error
			it.UpdatedFieldsContainsEvery, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains_some":
			var err error
			it.UpdatedFieldsContainsSome, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "node":
			var err error
			it.Node, err = ec.unmarshalODockerRegistryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalODockerRegistrySubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalODockerRegistrySubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalODockerRegistrySubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDockerRegistryUpdateInput(ctx context.Context, obj interface{}) (models.DockerRegistryUpdateInput, error) {
	var it models.DockerRegistryUpdateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "Hostname":
			var err error
			it.Hostname, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername":
			var err error
			it.AuthUsername, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword":
			var err error
			it.AuthPassword, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDockerRegistryUpdateManyMutationInput(ctx context.Context, obj interface{}) (models.DockerRegistryUpdateManyMutationInput, error) {
	var it models.DockerRegistryUpdateManyMutationInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "Hostname":
			var err error
			it.Hostname, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername":
			var err error
			it.AuthUsername, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword":
			var err error
			it.AuthPassword, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDockerRegistryWhereInput(ctx context.Context, obj interface{}) (models.DockerRegistryWhereInput, error) {
	var it models.DockerRegistryWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not":
			var err error
			it.IDNot, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_contains":
			var err error
			it.IDContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_contains":
			var err error
			it.IDNotContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_starts_with":
			var err error
			it.IDStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_starts_with":
			var err error
			it.IDNotStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ends_with":
			var err error
			it.IDEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_ends_with":
			var err error
			it.IDNotEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not":
			var err error
			it.CreatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_in":
			var err error
			it.CreatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not_in":
			var err error
			it.CreatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lt":
			var err error
			it.CreatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lte":
			var err error
			it.CreatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gt":
			var err error
			it.CreatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gte":
			var err error
			it.CreatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error
			it.UpdatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_not":
			var err error
			it.UpdatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_in":
			var err error
			it.UpdatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_not_in":
			var err error
			it.UpdatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lt":
			var err error
			it.UpdatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lte":
			var err error
			it.UpdatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gt":
			var err error
			it.UpdatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gte":
			var err error
			it.UpdatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname":
			var err error
			it.Hostname, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_not":
			var err error
			it.HostnameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_in":
			var err error
			it.HostnameIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_not_in":
			var err error
			it.HostnameNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_lt":
			var err error
			it.HostnameLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_lte":
			var err error
			it.HostnameLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_gt":
			var err error
			it.HostnameGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_gte":
			var err error
			it.HostnameGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_contains":
			var err error
			it.HostnameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_not_contains":
			var err error
			it.HostnameNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_starts_with":
			var err error
			it.HostnameStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_not_starts_with":
			var err error
			it.HostnameNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_ends_with":
			var err error
			it.HostnameEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "Hostname_not_ends_with":
			var err error
			it.HostnameNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername":
			var err error
			it.AuthUsername, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_not":
			var err error
			it.AuthUsernameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_in":
			var err error
			it.AuthUsernameIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_not_in":
			var err error
			it.AuthUsernameNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_lt":
			var err error
			it.AuthUsernameLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_lte":
			var err error
			it.AuthUsernameLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_gt":
			var err error
			it.AuthUsernameGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_gte":
			var err error
			it.AuthUsernameGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_contains":
			var err error
			it.AuthUsernameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_not_contains":
			var err error
			it.AuthUsernameNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_starts_with":
			var err error
			it.AuthUsernameStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_not_starts_with":
			var err error
			it.AuthUsernameNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_ends_with":
			var err error
			it.AuthUsernameEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthUsername_not_ends_with":
			var err error
			it.AuthUsernameNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword":
			var err error
			it.AuthPassword, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_not":
			var err error
			it.AuthPasswordNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_in":
			var err error
			it.AuthPasswordIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_not_in":
			var err error
			it.AuthPasswordNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_lt":
			var err error
			it.AuthPasswordLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_lte":
			var err error
			it.AuthPasswordLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_gt":
			var err error
			it.AuthPasswordGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_gte":
			var err error
			it.AuthPasswordGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_contains":
			var err error
			it.AuthPasswordContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_not_contains":
			var err error
			it.AuthPasswordNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_starts_with":
			var err error
			it.AuthPasswordStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_not_starts_with":
			var err error
			it.AuthPasswordNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_ends_with":
			var err error
			it.AuthPasswordEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AuthPassword_not_ends_with":
			var err error
			it.AuthPasswordNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalODockerRegistryWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalODockerRegistryWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalODockerRegistryWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDockerRegistryWhereUniqueInput(ctx context.Context, obj interface{}) (models.DockerRegistryWhereUniqueInput, error) {
	var it models.DockerRegistryWhereUniqueInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourceRepositoryCreateInput(ctx context.Context, obj interface{}) (models.SourceRepositoryCreateInput, error) {
	var it models.SourceRepositoryCreateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "owner":
			var err error
			it.Owner, err = ec.unmarshalNUserCreateOneInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateOneInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceProvider":
			var err error
			it.SourceProvider, err = ec.unmarshalOSourceProvider2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID":
			var err error
			it.AuthClientID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret":
			var err error
			it.AuthSecret, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "cloneStrategy":
			var err error
			it.CloneStrategy, err = ec.unmarshalNCloneStrategy2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildsEnabled":
			var err error
			it.BuildsEnabled, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName":
			var err error
			it.BaseConfigurationFileName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourceRepositoryCreateOneInput(ctx context.Context, obj interface{}) (models.SourceRepositoryCreateOneInput, error) {
	var it models.SourceRepositoryCreateOneInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "create":
			var err error
			it.Create, err = ec.unmarshalOSourceRepositoryCreateInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "connect":
			var err error
			it.Connect, err = ec.unmarshalOSourceRepositoryWhereUniqueInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereUniqueInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourceRepositorySubscriptionWhereInput(ctx context.Context, obj interface{}) (models.SourceRepositorySubscriptionWhereInput, error) {
	var it models.SourceRepositorySubscriptionWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "mutation_in":
			var err error
			it.MutationIn, err = ec.unmarshalOMutationType2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains":
			var err error
			it.UpdatedFieldsContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains_every":
			var err error
			it.UpdatedFieldsContainsEvery, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains_some":
			var err error
			it.UpdatedFieldsContainsSome, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "node":
			var err error
			it.Node, err = ec.unmarshalOSourceRepositoryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOSourceRepositorySubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOSourceRepositorySubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOSourceRepositorySubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourceRepositoryUpdateDataInput(ctx context.Context, obj interface{}) (models.SourceRepositoryUpdateDataInput, error) {
	var it models.SourceRepositoryUpdateDataInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "owner":
			var err error
			it.Owner, err = ec.unmarshalOUserUpdateOneRequiredInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateOneRequiredInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceProvider":
			var err error
			it.SourceProvider, err = ec.unmarshalOSourceProvider2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID":
			var err error
			it.AuthClientID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret":
			var err error
			it.AuthSecret, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "cloneStrategy":
			var err error
			it.CloneStrategy, err = ec.unmarshalOCloneStrategy2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildsEnabled":
			var err error
			it.BuildsEnabled, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName":
			var err error
			it.BaseConfigurationFileName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourceRepositoryUpdateInput(ctx context.Context, obj interface{}) (models.SourceRepositoryUpdateInput, error) {
	var it models.SourceRepositoryUpdateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "owner":
			var err error
			it.Owner, err = ec.unmarshalOUserUpdateOneRequiredInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateOneRequiredInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceProvider":
			var err error
			it.SourceProvider, err = ec.unmarshalOSourceProvider2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID":
			var err error
			it.AuthClientID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret":
			var err error
			it.AuthSecret, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "cloneStrategy":
			var err error
			it.CloneStrategy, err = ec.unmarshalOCloneStrategy2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildsEnabled":
			var err error
			it.BuildsEnabled, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName":
			var err error
			it.BaseConfigurationFileName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourceRepositoryUpdateManyMutationInput(ctx context.Context, obj interface{}) (models.SourceRepositoryUpdateManyMutationInput, error) {
	var it models.SourceRepositoryUpdateManyMutationInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "sourceProvider":
			var err error
			it.SourceProvider, err = ec.unmarshalOSourceProvider2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID":
			var err error
			it.AuthClientID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret":
			var err error
			it.AuthSecret, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "cloneStrategy":
			var err error
			it.CloneStrategy, err = ec.unmarshalOCloneStrategy2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildsEnabled":
			var err error
			it.BuildsEnabled, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName":
			var err error
			it.BaseConfigurationFileName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourceRepositoryUpdateOneRequiredInput(ctx context.Context, obj interface{}) (models.SourceRepositoryUpdateOneRequiredInput, error) {
	var it models.SourceRepositoryUpdateOneRequiredInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "create":
			var err error
			it.Create, err = ec.unmarshalOSourceRepositoryCreateInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "update":
			var err error
			it.Update, err = ec.unmarshalOSourceRepositoryUpdateDataInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateDataInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "upsert":
			var err error
			it.Upsert, err = ec.unmarshalOSourceRepositoryUpsertNestedInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpsertNestedInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "connect":
			var err error
			it.Connect, err = ec.unmarshalOSourceRepositoryWhereUniqueInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereUniqueInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourceRepositoryUpsertNestedInput(ctx context.Context, obj interface{}) (models.SourceRepositoryUpsertNestedInput, error) {
	var it models.SourceRepositoryUpsertNestedInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "update":
			var err error
			it.Update, err = ec.unmarshalNSourceRepositoryUpdateDataInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateDataInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "create":
			var err error
			it.Create, err = ec.unmarshalNSourceRepositoryCreateInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourceRepositoryWhereInput(ctx context.Context, obj interface{}) (models.SourceRepositoryWhereInput, error) {
	var it models.SourceRepositoryWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not":
			var err error
			it.IDNot, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_contains":
			var err error
			it.IDContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_contains":
			var err error
			it.IDNotContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_starts_with":
			var err error
			it.IDStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_starts_with":
			var err error
			it.IDNotStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ends_with":
			var err error
			it.IDEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_ends_with":
			var err error
			it.IDNotEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not":
			var err error
			it.CreatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_in":
			var err error
			it.CreatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not_in":
			var err error
			it.CreatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lt":
			var err error
			it.CreatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lte":
			var err error
			it.CreatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gt":
			var err error
			it.CreatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gte":
			var err error
			it.CreatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error
			it.UpdatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_not":
			var err error
			it.UpdatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_in":
			var err error
			it.UpdatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_not_in":
			var err error
			it.UpdatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lt":
			var err error
			it.UpdatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lte":
			var err error
			it.UpdatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gt":
			var err error
			it.UpdatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gte":
			var err error
			it.UpdatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "owner":
			var err error
			it.Owner, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceProvider":
			var err error
			it.SourceProvider, err = ec.unmarshalOSourceProvider2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceProvider_not":
			var err error
			it.SourceProviderNot, err = ec.unmarshalOSourceProvider2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceProvider_in":
			var err error
			it.SourceProviderIn, err = ec.unmarshalOSourceProvider2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, v)
			if err != nil {
				return it, err
			}
		case "sourceProvider_not_in":
			var err error
			it.SourceProviderNotIn, err = ec.unmarshalOSourceProvider2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_lt":
			var err error
			it.NameLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_lte":
			var err error
			it.NameLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_gt":
			var err error
			it.NameGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_gte":
			var err error
			it.NameGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_contains":
			var err error
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_contains":
			var err error
			it.NameNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_starts_with":
			var err error
			it.NameStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_starts_with":
			var err error
			it.NameNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ends_with":
			var err error
			it.NameEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ends_with":
			var err error
			it.NameNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID":
			var err error
			it.AuthClientID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_not":
			var err error
			it.AuthClientIDNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_in":
			var err error
			it.AuthClientIDIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_not_in":
			var err error
			it.AuthClientIDNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_lt":
			var err error
			it.AuthClientIDLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_lte":
			var err error
			it.AuthClientIDLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_gt":
			var err error
			it.AuthClientIDGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_gte":
			var err error
			it.AuthClientIDGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_contains":
			var err error
			it.AuthClientIDContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_not_contains":
			var err error
			it.AuthClientIDNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_starts_with":
			var err error
			it.AuthClientIDStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_not_starts_with":
			var err error
			it.AuthClientIDNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_ends_with":
			var err error
			it.AuthClientIDEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authClientID_not_ends_with":
			var err error
			it.AuthClientIDNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret":
			var err error
			it.AuthSecret, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_not":
			var err error
			it.AuthSecretNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_in":
			var err error
			it.AuthSecretIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_not_in":
			var err error
			it.AuthSecretNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_lt":
			var err error
			it.AuthSecretLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_lte":
			var err error
			it.AuthSecretLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_gt":
			var err error
			it.AuthSecretGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_gte":
			var err error
			it.AuthSecretGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_contains":
			var err error
			it.AuthSecretContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_not_contains":
			var err error
			it.AuthSecretNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_starts_with":
			var err error
			it.AuthSecretStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_not_starts_with":
			var err error
			it.AuthSecretNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_ends_with":
			var err error
			it.AuthSecretEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "authSecret_not_ends_with":
			var err error
			it.AuthSecretNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "cloneStrategy":
			var err error
			it.CloneStrategy, err = ec.unmarshalOCloneStrategy2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, v)
			if err != nil {
				return it, err
			}
		case "cloneStrategy_not":
			var err error
			it.CloneStrategyNot, err = ec.unmarshalOCloneStrategy2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, v)
			if err != nil {
				return it, err
			}
		case "cloneStrategy_in":
			var err error
			it.CloneStrategyIn, err = ec.unmarshalOCloneStrategy2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, v)
			if err != nil {
				return it, err
			}
		case "cloneStrategy_not_in":
			var err error
			it.CloneStrategyNotIn, err = ec.unmarshalOCloneStrategy2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildsEnabled":
			var err error
			it.BuildsEnabled, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildsEnabled_not":
			var err error
			it.BuildsEnabledNot, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName":
			var err error
			it.BaseConfigurationFileName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_not":
			var err error
			it.BaseConfigurationFileNameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_in":
			var err error
			it.BaseConfigurationFileNameIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_not_in":
			var err error
			it.BaseConfigurationFileNameNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_lt":
			var err error
			it.BaseConfigurationFileNameLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_lte":
			var err error
			it.BaseConfigurationFileNameLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_gt":
			var err error
			it.BaseConfigurationFileNameGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_gte":
			var err error
			it.BaseConfigurationFileNameGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_contains":
			var err error
			it.BaseConfigurationFileNameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_not_contains":
			var err error
			it.BaseConfigurationFileNameNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_starts_with":
			var err error
			it.BaseConfigurationFileNameStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_not_starts_with":
			var err error
			it.BaseConfigurationFileNameNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_ends_with":
			var err error
			it.BaseConfigurationFileNameEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseConfigurationFileName_not_ends_with":
			var err error
			it.BaseConfigurationFileNameNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOSourceRepositoryWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOSourceRepositoryWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOSourceRepositoryWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourceRepositoryWhereUniqueInput(ctx context.Context, obj interface{}) (models.SourceRepositoryWhereUniqueInput, error) {
	var it models.SourceRepositoryWhereUniqueInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserCreateInput(ctx context.Context, obj interface{}) (models.UserCreateInput, error) {
	var it models.UserCreateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash":
			var err error
			it.PasswordHash, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername":
			var err error
			it.GithubUsername, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken":
			var err error
			it.GithubAccountAuthToken, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken":
			var err error
			it.GoogleAccountAuthToken, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserCreateOneInput(ctx context.Context, obj interface{}) (models.UserCreateOneInput, error) {
	var it models.UserCreateOneInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "create":
			var err error
			it.Create, err = ec.unmarshalOUserCreateInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "connect":
			var err error
			it.Connect, err = ec.unmarshalOUserWhereUniqueInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereUniqueInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserSubscriptionWhereInput(ctx context.Context, obj interface{}) (models.UserSubscriptionWhereInput, error) {
	var it models.UserSubscriptionWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "mutation_in":
			var err error
			it.MutationIn, err = ec.unmarshalOMutationType2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains":
			var err error
			it.UpdatedFieldsContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains_every":
			var err error
			it.UpdatedFieldsContainsEvery, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedFields_contains_some":
			var err error
			it.UpdatedFieldsContainsSome, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "node":
			var err error
			it.Node, err = ec.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOUserSubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOUserSubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOUserSubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserUpdateDataInput(ctx context.Context, obj interface{}) (models.UserUpdateDataInput, error) {
	var it models.UserUpdateDataInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash":
			var err error
			it.PasswordHash, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername":
			var err error
			it.GithubUsername, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken":
			var err error
			it.GithubAccountAuthToken, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken":
			var err error
			it.GoogleAccountAuthToken, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserUpdateInput(ctx context.Context, obj interface{}) (models.UserUpdateInput, error) {
	var it models.UserUpdateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash":
			var err error
			it.PasswordHash, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername":
			var err error
			it.GithubUsername, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken":
			var err error
			it.GithubAccountAuthToken, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken":
			var err error
			it.GoogleAccountAuthToken, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserUpdateManyMutationInput(ctx context.Context, obj interface{}) (models.UserUpdateManyMutationInput, error) {
	var it models.UserUpdateManyMutationInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash":
			var err error
			it.PasswordHash, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername":
			var err error
			it.GithubUsername, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken":
			var err error
			it.GithubAccountAuthToken, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken":
			var err error
			it.GoogleAccountAuthToken, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserUpdateOneRequiredInput(ctx context.Context, obj interface{}) (models.UserUpdateOneRequiredInput, error) {
	var it models.UserUpdateOneRequiredInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "create":
			var err error
			it.Create, err = ec.unmarshalOUserCreateInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "update":
			var err error
			it.Update, err = ec.unmarshalOUserUpdateDataInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateDataInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "upsert":
			var err error
			it.Upsert, err = ec.unmarshalOUserUpsertNestedInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpsertNestedInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "connect":
			var err error
			it.Connect, err = ec.unmarshalOUserWhereUniqueInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereUniqueInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserUpsertNestedInput(ctx context.Context, obj interface{}) (models.UserUpsertNestedInput, error) {
	var it models.UserUpsertNestedInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "update":
			var err error
			it.Update, err = ec.unmarshalNUserUpdateDataInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateDataInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "create":
			var err error
			it.Create, err = ec.unmarshalNUserCreateInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereInput(ctx context.Context, obj interface{}) (models.UserWhereInput, error) {
	var it models.UserWhereInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not":
			var err error
			it.IDNot, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_in":
			var err error
			it.IDIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_in":
			var err error
			it.IDNotIn, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lt":
			var err error
			it.IDLt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_lte":
			var err error
			it.IDLte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gt":
			var err error
			it.IDGt, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_gte":
			var err error
			it.IDGte, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_contains":
			var err error
			it.IDContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_contains":
			var err error
			it.IDNotContains, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_starts_with":
			var err error
			it.IDStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_starts_with":
			var err error
			it.IDNotStartsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_ends_with":
			var err error
			it.IDEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "id_not_ends_with":
			var err error
			it.IDNotEndsWith, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not":
			var err error
			it.CreatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_in":
			var err error
			it.CreatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_not_in":
			var err error
			it.CreatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lt":
			var err error
			it.CreatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_lte":
			var err error
			it.CreatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gt":
			var err error
			it.CreatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt_gte":
			var err error
			it.CreatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error
			it.UpdatedAt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_not":
			var err error
			it.UpdatedAtNot, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_in":
			var err error
			it.UpdatedAtIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_not_in":
			var err error
			it.UpdatedAtNotIn, err = ec.unmarshalODateTime2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lt":
			var err error
			it.UpdatedAtLt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_lte":
			var err error
			it.UpdatedAtLte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gt":
			var err error
			it.UpdatedAtGt, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt_gte":
			var err error
			it.UpdatedAtGte, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not":
			var err error
			it.NameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_in":
			var err error
			it.NameIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_in":
			var err error
			it.NameNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_lt":
			var err error
			it.NameLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_lte":
			var err error
			it.NameLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_gt":
			var err error
			it.NameGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_gte":
			var err error
			it.NameGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_contains":
			var err error
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_contains":
			var err error
			it.NameNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_starts_with":
			var err error
			it.NameStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_starts_with":
			var err error
			it.NameNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_ends_with":
			var err error
			it.NameEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name_not_ends_with":
			var err error
			it.NameNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_not":
			var err error
			it.EmailNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_in":
			var err error
			it.EmailIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_not_in":
			var err error
			it.EmailNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_lt":
			var err error
			it.EmailLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_lte":
			var err error
			it.EmailLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_gt":
			var err error
			it.EmailGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_gte":
			var err error
			it.EmailGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_contains":
			var err error
			it.EmailContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_not_contains":
			var err error
			it.EmailNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_starts_with":
			var err error
			it.EmailStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_not_starts_with":
			var err error
			it.EmailNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_ends_with":
			var err error
			it.EmailEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email_not_ends_with":
			var err error
			it.EmailNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash":
			var err error
			it.PasswordHash, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_not":
			var err error
			it.PasswordHashNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_in":
			var err error
			it.PasswordHashIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_not_in":
			var err error
			it.PasswordHashNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_lt":
			var err error
			it.PasswordHashLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_lte":
			var err error
			it.PasswordHashLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_gt":
			var err error
			it.PasswordHashGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_gte":
			var err error
			it.PasswordHashGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_contains":
			var err error
			it.PasswordHashContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_not_contains":
			var err error
			it.PasswordHashNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_starts_with":
			var err error
			it.PasswordHashStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_not_starts_with":
			var err error
			it.PasswordHashNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_ends_with":
			var err error
			it.PasswordHashEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordHash_not_ends_with":
			var err error
			it.PasswordHashNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername":
			var err error
			it.GithubUsername, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_not":
			var err error
			it.GithubUsernameNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_in":
			var err error
			it.GithubUsernameIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_not_in":
			var err error
			it.GithubUsernameNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_lt":
			var err error
			it.GithubUsernameLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_lte":
			var err error
			it.GithubUsernameLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_gt":
			var err error
			it.GithubUsernameGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_gte":
			var err error
			it.GithubUsernameGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_contains":
			var err error
			it.GithubUsernameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_not_contains":
			var err error
			it.GithubUsernameNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_starts_with":
			var err error
			it.GithubUsernameStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_not_starts_with":
			var err error
			it.GithubUsernameNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_ends_with":
			var err error
			it.GithubUsernameEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubUsername_not_ends_with":
			var err error
			it.GithubUsernameNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken":
			var err error
			it.GithubAccountAuthToken, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_not":
			var err error
			it.GithubAccountAuthTokenNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_in":
			var err error
			it.GithubAccountAuthTokenIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_not_in":
			var err error
			it.GithubAccountAuthTokenNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_lt":
			var err error
			it.GithubAccountAuthTokenLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_lte":
			var err error
			it.GithubAccountAuthTokenLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_gt":
			var err error
			it.GithubAccountAuthTokenGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_gte":
			var err error
			it.GithubAccountAuthTokenGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_contains":
			var err error
			it.GithubAccountAuthTokenContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_not_contains":
			var err error
			it.GithubAccountAuthTokenNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_starts_with":
			var err error
			it.GithubAccountAuthTokenStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_not_starts_with":
			var err error
			it.GithubAccountAuthTokenNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_ends_with":
			var err error
			it.GithubAccountAuthTokenEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "githubAccountAuthToken_not_ends_with":
			var err error
			it.GithubAccountAuthTokenNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken":
			var err error
			it.GoogleAccountAuthToken, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_not":
			var err error
			it.GoogleAccountAuthTokenNot, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_in":
			var err error
			it.GoogleAccountAuthTokenIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_not_in":
			var err error
			it.GoogleAccountAuthTokenNotIn, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_lt":
			var err error
			it.GoogleAccountAuthTokenLt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_lte":
			var err error
			it.GoogleAccountAuthTokenLte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_gt":
			var err error
			it.GoogleAccountAuthTokenGt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_gte":
			var err error
			it.GoogleAccountAuthTokenGte, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_contains":
			var err error
			it.GoogleAccountAuthTokenContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_not_contains":
			var err error
			it.GoogleAccountAuthTokenNotContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_starts_with":
			var err error
			it.GoogleAccountAuthTokenStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_not_starts_with":
			var err error
			it.GoogleAccountAuthTokenNotStartsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_ends_with":
			var err error
			it.GoogleAccountAuthTokenEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "googleAccountAuthToken_not_ends_with":
			var err error
			it.GoogleAccountAuthTokenNotEndsWith, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "AND":
			var err error
			it.And, err = ec.unmarshalOUserWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "OR":
			var err error
			it.Or, err = ec.unmarshalOUserWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "NOT":
			var err error
			it.Not, err = ec.unmarshalOUserWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereUniqueInput(ctx context.Context, obj interface{}) (models.UserWhereUniqueInput, error) {
	var it models.UserWhereUniqueInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj *models.Node) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var aggregateBuildJobImplementors = []string{"AggregateBuildJob"}

func (ec *executionContext) _AggregateBuildJob(ctx context.Context, sel ast.SelectionSet, obj *models.AggregateBuildJob) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, aggregateBuildJobImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AggregateBuildJob")
		case "count":
			out.Values[i] = ec._AggregateBuildJob_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var aggregateDockerRegistryImplementors = []string{"AggregateDockerRegistry"}

func (ec *executionContext) _AggregateDockerRegistry(ctx context.Context, sel ast.SelectionSet, obj *models.AggregateDockerRegistry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, aggregateDockerRegistryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AggregateDockerRegistry")
		case "count":
			out.Values[i] = ec._AggregateDockerRegistry_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var aggregateSourceRepositoryImplementors = []string{"AggregateSourceRepository"}

func (ec *executionContext) _AggregateSourceRepository(ctx context.Context, sel ast.SelectionSet, obj *models.AggregateSourceRepository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, aggregateSourceRepositoryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AggregateSourceRepository")
		case "count":
			out.Values[i] = ec._AggregateSourceRepository_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var aggregateUserImplementors = []string{"AggregateUser"}

func (ec *executionContext) _AggregateUser(ctx context.Context, sel ast.SelectionSet, obj *models.AggregateUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, aggregateUserImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AggregateUser")
		case "count":
			out.Values[i] = ec._AggregateUser_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var batchPayloadImplementors = []string{"BatchPayload"}

func (ec *executionContext) _BatchPayload(ctx context.Context, sel ast.SelectionSet, obj *models.BatchPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, batchPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BatchPayload")
		case "count":
			out.Values[i] = ec._BatchPayload_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildJobImplementors = []string{"BuildJob"}

func (ec *executionContext) _BuildJob(ctx context.Context, sel ast.SelectionSet, obj *models.BuildJob) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, buildJobImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildJob")
		case "id":
			out.Values[i] = ec._BuildJob_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._BuildJob_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._BuildJob_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "completedAt":
			out.Values[i] = ec._BuildJob_completedAt(ctx, field, obj)
		case "buildHostKind":
			out.Values[i] = ec._BuildJob_buildHostKind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildHostIdentifier":
			out.Values[i] = ec._BuildJob_buildHostIdentifier(ctx, field, obj)
		case "repo":
			out.Values[i] = ec._BuildJob_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "status":
			out.Values[i] = ec._BuildJob_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildIdentifier":
			out.Values[i] = ec._BuildJob_buildIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sourceRevision":
			out.Values[i] = ec._BuildJob_sourceRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "artifactUri":
			out.Values[i] = ec._BuildJob_artifactUri(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "setupLogs":
			out.Values[i] = ec._BuildJob_setupLogs(ctx, field, obj)
		case "buildLogs":
			out.Values[i] = ec._BuildJob_buildLogs(ctx, field, obj)
		case "pushLogs":
			out.Values[i] = ec._BuildJob_pushLogs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildJobConnectionImplementors = []string{"BuildJobConnection"}

func (ec *executionContext) _BuildJobConnection(ctx context.Context, sel ast.SelectionSet, obj *models.BuildJobConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, buildJobConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildJobConnection")
		case "pageInfo":
			out.Values[i] = ec._BuildJobConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			out.Values[i] = ec._BuildJobConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "aggregate":
			out.Values[i] = ec._BuildJobConnection_aggregate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildJobEdgeImplementors = []string{"BuildJobEdge"}

func (ec *executionContext) _BuildJobEdge(ctx context.Context, sel ast.SelectionSet, obj *models.BuildJobEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, buildJobEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildJobEdge")
		case "node":
			out.Values[i] = ec._BuildJobEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cursor":
			out.Values[i] = ec._BuildJobEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildJobPreviousValuesImplementors = []string{"BuildJobPreviousValues"}

func (ec *executionContext) _BuildJobPreviousValues(ctx context.Context, sel ast.SelectionSet, obj *models.BuildJobPreviousValues) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, buildJobPreviousValuesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildJobPreviousValues")
		case "id":
			out.Values[i] = ec._BuildJobPreviousValues_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._BuildJobPreviousValues_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._BuildJobPreviousValues_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "completedAt":
			out.Values[i] = ec._BuildJobPreviousValues_completedAt(ctx, field, obj)
		case "buildHostKind":
			out.Values[i] = ec._BuildJobPreviousValues_buildHostKind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildHostIdentifier":
			out.Values[i] = ec._BuildJobPreviousValues_buildHostIdentifier(ctx, field, obj)
		case "status":
			out.Values[i] = ec._BuildJobPreviousValues_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildIdentifier":
			out.Values[i] = ec._BuildJobPreviousValues_buildIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sourceRevision":
			out.Values[i] = ec._BuildJobPreviousValues_sourceRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "artifactUri":
			out.Values[i] = ec._BuildJobPreviousValues_artifactUri(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "setupLogs":
			out.Values[i] = ec._BuildJobPreviousValues_setupLogs(ctx, field, obj)
		case "buildLogs":
			out.Values[i] = ec._BuildJobPreviousValues_buildLogs(ctx, field, obj)
		case "pushLogs":
			out.Values[i] = ec._BuildJobPreviousValues_pushLogs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildJobSubscriptionPayloadImplementors = []string{"BuildJobSubscriptionPayload"}

func (ec *executionContext) _BuildJobSubscriptionPayload(ctx context.Context, sel ast.SelectionSet, obj *models.BuildJobSubscriptionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, buildJobSubscriptionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildJobSubscriptionPayload")
		case "mutation":
			out.Values[i] = ec._BuildJobSubscriptionPayload_mutation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":
			out.Values[i] = ec._BuildJobSubscriptionPayload_node(ctx, field, obj)
		case "updatedFields":
			out.Values[i] = ec._BuildJobSubscriptionPayload_updatedFields(ctx, field, obj)
		case "previousValues":
			out.Values[i] = ec._BuildJobSubscriptionPayload_previousValues(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dockerRegistryImplementors = []string{"DockerRegistry"}

func (ec *executionContext) _DockerRegistry(ctx context.Context, sel ast.SelectionSet, obj *models.DockerRegistry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, dockerRegistryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DockerRegistry")
		case "id":
			out.Values[i] = ec._DockerRegistry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._DockerRegistry_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._DockerRegistry_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Hostname":
			out.Values[i] = ec._DockerRegistry_Hostname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthUsername":
			out.Values[i] = ec._DockerRegistry_AuthUsername(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthPassword":
			out.Values[i] = ec._DockerRegistry_AuthPassword(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dockerRegistryConnectionImplementors = []string{"DockerRegistryConnection"}

func (ec *executionContext) _DockerRegistryConnection(ctx context.Context, sel ast.SelectionSet, obj *models.DockerRegistryConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, dockerRegistryConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DockerRegistryConnection")
		case "pageInfo":
			out.Values[i] = ec._DockerRegistryConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			out.Values[i] = ec._DockerRegistryConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "aggregate":
			out.Values[i] = ec._DockerRegistryConnection_aggregate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dockerRegistryEdgeImplementors = []string{"DockerRegistryEdge"}

func (ec *executionContext) _DockerRegistryEdge(ctx context.Context, sel ast.SelectionSet, obj *models.DockerRegistryEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, dockerRegistryEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DockerRegistryEdge")
		case "node":
			out.Values[i] = ec._DockerRegistryEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cursor":
			out.Values[i] = ec._DockerRegistryEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dockerRegistryPreviousValuesImplementors = []string{"DockerRegistryPreviousValues"}

func (ec *executionContext) _DockerRegistryPreviousValues(ctx context.Context, sel ast.SelectionSet, obj *models.DockerRegistryPreviousValues) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, dockerRegistryPreviousValuesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DockerRegistryPreviousValues")
		case "id":
			out.Values[i] = ec._DockerRegistryPreviousValues_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._DockerRegistryPreviousValues_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._DockerRegistryPreviousValues_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Hostname":
			out.Values[i] = ec._DockerRegistryPreviousValues_Hostname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthUsername":
			out.Values[i] = ec._DockerRegistryPreviousValues_AuthUsername(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AuthPassword":
			out.Values[i] = ec._DockerRegistryPreviousValues_AuthPassword(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dockerRegistrySubscriptionPayloadImplementors = []string{"DockerRegistrySubscriptionPayload"}

func (ec *executionContext) _DockerRegistrySubscriptionPayload(ctx context.Context, sel ast.SelectionSet, obj *models.DockerRegistrySubscriptionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, dockerRegistrySubscriptionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DockerRegistrySubscriptionPayload")
		case "mutation":
			out.Values[i] = ec._DockerRegistrySubscriptionPayload_mutation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":
			out.Values[i] = ec._DockerRegistrySubscriptionPayload_node(ctx, field, obj)
		case "updatedFields":
			out.Values[i] = ec._DockerRegistrySubscriptionPayload_updatedFields(ctx, field, obj)
		case "previousValues":
			out.Values[i] = ec._DockerRegistrySubscriptionPayload_previousValues(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createBuildJob":
			out.Values[i] = ec._Mutation_createBuildJob(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateBuildJob":
			out.Values[i] = ec._Mutation_updateBuildJob(ctx, field)
		case "updateManyBuildJobs":
			out.Values[i] = ec._Mutation_updateManyBuildJobs(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "upsertBuildJob":
			out.Values[i] = ec._Mutation_upsertBuildJob(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteBuildJob":
			out.Values[i] = ec._Mutation_deleteBuildJob(ctx, field)
		case "deleteManyBuildJobs":
			out.Values[i] = ec._Mutation_deleteManyBuildJobs(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createDockerRegistry":
			out.Values[i] = ec._Mutation_createDockerRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateDockerRegistry":
			out.Values[i] = ec._Mutation_updateDockerRegistry(ctx, field)
		case "updateManyDockerRegistries":
			out.Values[i] = ec._Mutation_updateManyDockerRegistries(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "upsertDockerRegistry":
			out.Values[i] = ec._Mutation_upsertDockerRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteDockerRegistry":
			out.Values[i] = ec._Mutation_deleteDockerRegistry(ctx, field)
		case "deleteManyDockerRegistries":
			out.Values[i] = ec._Mutation_deleteManyDockerRegistries(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createSourceRepository":
			out.Values[i] = ec._Mutation_createSourceRepository(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateSourceRepository":
			out.Values[i] = ec._Mutation_updateSourceRepository(ctx, field)
		case "updateManySourceRepositories":
			out.Values[i] = ec._Mutation_updateManySourceRepositories(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "upsertSourceRepository":
			out.Values[i] = ec._Mutation_upsertSourceRepository(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteSourceRepository":
			out.Values[i] = ec._Mutation_deleteSourceRepository(ctx, field)
		case "deleteManySourceRepositories":
			out.Values[i] = ec._Mutation_deleteManySourceRepositories(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createUser":
			out.Values[i] = ec._Mutation_createUser(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateUser":
			out.Values[i] = ec._Mutation_updateUser(ctx, field)
		case "updateManyUsers":
			out.Values[i] = ec._Mutation_updateManyUsers(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "upsertUser":
			out.Values[i] = ec._Mutation_upsertUser(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteUser":
			out.Values[i] = ec._Mutation_deleteUser(ctx, field)
		case "deleteManyUsers":
			out.Values[i] = ec._Mutation_deleteManyUsers(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *models.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "buildJob":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_buildJob(ctx, field)
				return res
			})
		case "buildJobs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_buildJobs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "buildJobsConnection":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_buildJobsConnection(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dockerRegistry":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_dockerRegistry(ctx, field)
				return res
			})
		case "dockerRegistries":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_dockerRegistries(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dockerRegistriesConnection":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_dockerRegistriesConnection(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "sourceRepository":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sourceRepository(ctx, field)
				return res
			})
		case "sourceRepositories":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sourceRepositories(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "sourceRepositoriesConnection":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sourceRepositoriesConnection(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "user":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				return res
			})
		case "users":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "usersConnection":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_usersConnection(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "node":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sourceRepositoryImplementors = []string{"SourceRepository"}

func (ec *executionContext) _SourceRepository(ctx context.Context, sel ast.SelectionSet, obj *models.SourceRepository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, sourceRepositoryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SourceRepository")
		case "id":
			out.Values[i] = ec._SourceRepository_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._SourceRepository_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._SourceRepository_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "owner":
			out.Values[i] = ec._SourceRepository_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sourceProvider":
			out.Values[i] = ec._SourceRepository_sourceProvider(ctx, field, obj)
		case "name":
			out.Values[i] = ec._SourceRepository_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "authClientID":
			out.Values[i] = ec._SourceRepository_authClientID(ctx, field, obj)
		case "authSecret":
			out.Values[i] = ec._SourceRepository_authSecret(ctx, field, obj)
		case "cloneStrategy":
			out.Values[i] = ec._SourceRepository_cloneStrategy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildsEnabled":
			out.Values[i] = ec._SourceRepository_buildsEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "baseConfigurationFileName":
			out.Values[i] = ec._SourceRepository_baseConfigurationFileName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sourceRepositoryConnectionImplementors = []string{"SourceRepositoryConnection"}

func (ec *executionContext) _SourceRepositoryConnection(ctx context.Context, sel ast.SelectionSet, obj *models.SourceRepositoryConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, sourceRepositoryConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SourceRepositoryConnection")
		case "pageInfo":
			out.Values[i] = ec._SourceRepositoryConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			out.Values[i] = ec._SourceRepositoryConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "aggregate":
			out.Values[i] = ec._SourceRepositoryConnection_aggregate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sourceRepositoryEdgeImplementors = []string{"SourceRepositoryEdge"}

func (ec *executionContext) _SourceRepositoryEdge(ctx context.Context, sel ast.SelectionSet, obj *models.SourceRepositoryEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, sourceRepositoryEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SourceRepositoryEdge")
		case "node":
			out.Values[i] = ec._SourceRepositoryEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cursor":
			out.Values[i] = ec._SourceRepositoryEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sourceRepositoryPreviousValuesImplementors = []string{"SourceRepositoryPreviousValues"}

func (ec *executionContext) _SourceRepositoryPreviousValues(ctx context.Context, sel ast.SelectionSet, obj *models.SourceRepositoryPreviousValues) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, sourceRepositoryPreviousValuesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SourceRepositoryPreviousValues")
		case "id":
			out.Values[i] = ec._SourceRepositoryPreviousValues_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._SourceRepositoryPreviousValues_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._SourceRepositoryPreviousValues_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sourceProvider":
			out.Values[i] = ec._SourceRepositoryPreviousValues_sourceProvider(ctx, field, obj)
		case "name":
			out.Values[i] = ec._SourceRepositoryPreviousValues_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "authClientID":
			out.Values[i] = ec._SourceRepositoryPreviousValues_authClientID(ctx, field, obj)
		case "authSecret":
			out.Values[i] = ec._SourceRepositoryPreviousValues_authSecret(ctx, field, obj)
		case "cloneStrategy":
			out.Values[i] = ec._SourceRepositoryPreviousValues_cloneStrategy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildsEnabled":
			out.Values[i] = ec._SourceRepositoryPreviousValues_buildsEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "baseConfigurationFileName":
			out.Values[i] = ec._SourceRepositoryPreviousValues_baseConfigurationFileName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sourceRepositorySubscriptionPayloadImplementors = []string{"SourceRepositorySubscriptionPayload"}

func (ec *executionContext) _SourceRepositorySubscriptionPayload(ctx context.Context, sel ast.SelectionSet, obj *models.SourceRepositorySubscriptionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, sourceRepositorySubscriptionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SourceRepositorySubscriptionPayload")
		case "mutation":
			out.Values[i] = ec._SourceRepositorySubscriptionPayload_mutation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":
			out.Values[i] = ec._SourceRepositorySubscriptionPayload_node(ctx, field, obj)
		case "updatedFields":
			out.Values[i] = ec._SourceRepositorySubscriptionPayload_updatedFields(ctx, field, obj)
		case "previousValues":
			out.Values[i] = ec._SourceRepositorySubscriptionPayload_previousValues(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, subscriptionImplementors)
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "buildJob":
		return ec._Subscription_buildJob(ctx, fields[0])
	case "dockerRegistry":
		return ec._Subscription_dockerRegistry(ctx, fields[0])
	case "sourceRepository":
		return ec._Subscription_sourceRepository(ctx, fields[0])
	case "user":
		return ec._Subscription_user(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *models.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._User_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "passwordHash":
			out.Values[i] = ec._User_passwordHash(ctx, field, obj)
		case "githubUsername":
			out.Values[i] = ec._User_githubUsername(ctx, field, obj)
		case "githubAccountAuthToken":
			out.Values[i] = ec._User_githubAccountAuthToken(ctx, field, obj)
		case "googleAccountAuthToken":
			out.Values[i] = ec._User_googleAccountAuthToken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userConnectionImplementors = []string{"UserConnection"}

func (ec *executionContext) _UserConnection(ctx context.Context, sel ast.SelectionSet, obj *models.UserConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, userConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConnection")
		case "pageInfo":
			out.Values[i] = ec._UserConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			out.Values[i] = ec._UserConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "aggregate":
			out.Values[i] = ec._UserConnection_aggregate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userEdgeImplementors = []string{"UserEdge"}

func (ec *executionContext) _UserEdge(ctx context.Context, sel ast.SelectionSet, obj *models.UserEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, userEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserEdge")
		case "node":
			out.Values[i] = ec._UserEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cursor":
			out.Values[i] = ec._UserEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userPreviousValuesImplementors = []string{"UserPreviousValues"}

func (ec *executionContext) _UserPreviousValues(ctx context.Context, sel ast.SelectionSet, obj *models.UserPreviousValues) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, userPreviousValuesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserPreviousValues")
		case "id":
			out.Values[i] = ec._UserPreviousValues_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._UserPreviousValues_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._UserPreviousValues_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._UserPreviousValues_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "email":
			out.Values[i] = ec._UserPreviousValues_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "passwordHash":
			out.Values[i] = ec._UserPreviousValues_passwordHash(ctx, field, obj)
		case "githubUsername":
			out.Values[i] = ec._UserPreviousValues_githubUsername(ctx, field, obj)
		case "githubAccountAuthToken":
			out.Values[i] = ec._UserPreviousValues_githubAccountAuthToken(ctx, field, obj)
		case "googleAccountAuthToken":
			out.Values[i] = ec._UserPreviousValues_googleAccountAuthToken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userSubscriptionPayloadImplementors = []string{"UserSubscriptionPayload"}

func (ec *executionContext) _UserSubscriptionPayload(ctx context.Context, sel ast.SelectionSet, obj *models.UserSubscriptionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, userSubscriptionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSubscriptionPayload")
		case "mutation":
			out.Values[i] = ec._UserSubscriptionPayload_mutation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":
			out.Values[i] = ec._UserSubscriptionPayload_node(ctx, field, obj)
		case "updatedFields":
			out.Values[i] = ec._UserSubscriptionPayload_updatedFields(ctx, field, obj)
		case "previousValues":
			out.Values[i] = ec._UserSubscriptionPayload_previousValues(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAggregateBuildJob2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateBuildJob(ctx context.Context, sel ast.SelectionSet, v models.AggregateBuildJob) graphql.Marshaler {
	return ec._AggregateBuildJob(ctx, sel, &v)
}

func (ec *executionContext) marshalNAggregateBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateBuildJob(ctx context.Context, sel ast.SelectionSet, v *models.AggregateBuildJob) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AggregateBuildJob(ctx, sel, v)
}

func (ec *executionContext) marshalNAggregateDockerRegistry2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateDockerRegistry(ctx context.Context, sel ast.SelectionSet, v models.AggregateDockerRegistry) graphql.Marshaler {
	return ec._AggregateDockerRegistry(ctx, sel, &v)
}

func (ec *executionContext) marshalNAggregateDockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateDockerRegistry(ctx context.Context, sel ast.SelectionSet, v *models.AggregateDockerRegistry) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AggregateDockerRegistry(ctx, sel, v)
}

func (ec *executionContext) marshalNAggregateSourceRepository2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateSourceRepository(ctx context.Context, sel ast.SelectionSet, v models.AggregateSourceRepository) graphql.Marshaler {
	return ec._AggregateSourceRepository(ctx, sel, &v)
}

func (ec *executionContext) marshalNAggregateSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateSourceRepository(ctx context.Context, sel ast.SelectionSet, v *models.AggregateSourceRepository) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AggregateSourceRepository(ctx, sel, v)
}

func (ec *executionContext) marshalNAggregateUser2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateUser(ctx context.Context, sel ast.SelectionSet, v models.AggregateUser) graphql.Marshaler {
	return ec._AggregateUser(ctx, sel, &v)
}

func (ec *executionContext) marshalNAggregateUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐAggregateUser(ctx context.Context, sel ast.SelectionSet, v *models.AggregateUser) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AggregateUser(ctx, sel, v)
}

func (ec *executionContext) marshalNBatchPayload2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBatchPayload(ctx context.Context, sel ast.SelectionSet, v models.BatchPayload) graphql.Marshaler {
	return ec._BatchPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNBatchPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBatchPayload(ctx context.Context, sel ast.SelectionSet, v *models.BatchPayload) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._BatchPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBuildHost2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx context.Context, v interface{}) (models.BuildHost, error) {
	var res models.BuildHost
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNBuildHost2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx context.Context, sel ast.SelectionSet, v models.BuildHost) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBuildJob2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx context.Context, sel ast.SelectionSet, v models.BuildJob) graphql.Marshaler {
	return ec._BuildJob(ctx, sel, &v)
}

func (ec *executionContext) marshalNBuildJob2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx context.Context, sel ast.SelectionSet, v []*models.BuildJob) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx context.Context, sel ast.SelectionSet, v *models.BuildJob) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._BuildJob(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildJobConnection2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobConnection(ctx context.Context, sel ast.SelectionSet, v models.BuildJobConnection) graphql.Marshaler {
	return ec._BuildJobConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNBuildJobConnection2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobConnection(ctx context.Context, sel ast.SelectionSet, v *models.BuildJobConnection) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._BuildJobConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBuildJobCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobCreateInput(ctx context.Context, v interface{}) (models.BuildJobCreateInput, error) {
	return ec.unmarshalInputBuildJobCreateInput(ctx, v)
}

func (ec *executionContext) marshalNBuildJobEdge2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobEdge(ctx context.Context, sel ast.SelectionSet, v []*models.BuildJobEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBuildJobEdge2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNBuildJobStatus2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx context.Context, v interface{}) (models.BuildJobStatus, error) {
	var res models.BuildJobStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNBuildJobStatus2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx context.Context, sel ast.SelectionSet, v models.BuildJobStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBuildJobSubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx context.Context, v interface{}) (models.BuildJobSubscriptionWhereInput, error) {
	return ec.unmarshalInputBuildJobSubscriptionWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNBuildJobSubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx context.Context, v interface{}) (*models.BuildJobSubscriptionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNBuildJobSubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNBuildJobUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobUpdateInput(ctx context.Context, v interface{}) (models.BuildJobUpdateInput, error) {
	return ec.unmarshalInputBuildJobUpdateInput(ctx, v)
}

func (ec *executionContext) unmarshalNBuildJobUpdateManyMutationInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobUpdateManyMutationInput(ctx context.Context, v interface{}) (models.BuildJobUpdateManyMutationInput, error) {
	return ec.unmarshalInputBuildJobUpdateManyMutationInput(ctx, v)
}

func (ec *executionContext) unmarshalNBuildJobWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx context.Context, v interface{}) (models.BuildJobWhereInput, error) {
	return ec.unmarshalInputBuildJobWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNBuildJobWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx context.Context, v interface{}) (*models.BuildJobWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNBuildJobWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNBuildJobWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereUniqueInput(ctx context.Context, v interface{}) (models.BuildJobWhereUniqueInput, error) {
	return ec.unmarshalInputBuildJobWhereUniqueInput(ctx, v)
}

func (ec *executionContext) unmarshalNCloneStrategy2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx context.Context, v interface{}) (models.CloneStrategy, error) {
	var res models.CloneStrategy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNCloneStrategy2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx context.Context, sel ast.SelectionSet, v models.CloneStrategy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDateTime2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNDateTime2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNDockerRegistry2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx context.Context, sel ast.SelectionSet, v models.DockerRegistry) graphql.Marshaler {
	return ec._DockerRegistry(ctx, sel, &v)
}

func (ec *executionContext) marshalNDockerRegistry2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx context.Context, sel ast.SelectionSet, v []*models.DockerRegistry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNDockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx context.Context, sel ast.SelectionSet, v *models.DockerRegistry) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._DockerRegistry(ctx, sel, v)
}

func (ec *executionContext) marshalNDockerRegistryConnection2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryConnection(ctx context.Context, sel ast.SelectionSet, v models.DockerRegistryConnection) graphql.Marshaler {
	return ec._DockerRegistryConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNDockerRegistryConnection2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryConnection(ctx context.Context, sel ast.SelectionSet, v *models.DockerRegistryConnection) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._DockerRegistryConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDockerRegistryCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryCreateInput(ctx context.Context, v interface{}) (models.DockerRegistryCreateInput, error) {
	return ec.unmarshalInputDockerRegistryCreateInput(ctx, v)
}

func (ec *executionContext) marshalNDockerRegistryEdge2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryEdge(ctx context.Context, sel ast.SelectionSet, v []*models.DockerRegistryEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODockerRegistryEdge2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNDockerRegistrySubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx context.Context, v interface{}) (models.DockerRegistrySubscriptionWhereInput, error) {
	return ec.unmarshalInputDockerRegistrySubscriptionWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNDockerRegistrySubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx context.Context, v interface{}) (*models.DockerRegistrySubscriptionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNDockerRegistrySubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNDockerRegistryUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryUpdateInput(ctx context.Context, v interface{}) (models.DockerRegistryUpdateInput, error) {
	return ec.unmarshalInputDockerRegistryUpdateInput(ctx, v)
}

func (ec *executionContext) unmarshalNDockerRegistryUpdateManyMutationInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryUpdateManyMutationInput(ctx context.Context, v interface{}) (models.DockerRegistryUpdateManyMutationInput, error) {
	return ec.unmarshalInputDockerRegistryUpdateManyMutationInput(ctx, v)
}

func (ec *executionContext) unmarshalNDockerRegistryWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx context.Context, v interface{}) (models.DockerRegistryWhereInput, error) {
	return ec.unmarshalInputDockerRegistryWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNDockerRegistryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx context.Context, v interface{}) (*models.DockerRegistryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNDockerRegistryWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNDockerRegistryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereUniqueInput(ctx context.Context, v interface{}) (models.DockerRegistryWhereUniqueInput, error) {
	return ec.unmarshalInputDockerRegistryWhereUniqueInput(ctx, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNLong2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNLong2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMutationType2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx context.Context, v interface{}) (models.MutationType, error) {
	var res models.MutationType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNMutationType2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx context.Context, sel ast.SelectionSet, v models.MutationType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v models.PageInfo) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNPageInfo2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v *models.PageInfo) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSourceProvider2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx context.Context, v interface{}) (models.SourceProvider, error) {
	var res models.SourceProvider
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNSourceProvider2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx context.Context, sel ast.SelectionSet, v models.SourceProvider) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSourceRepository2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx context.Context, sel ast.SelectionSet, v models.SourceRepository) graphql.Marshaler {
	return ec._SourceRepository(ctx, sel, &v)
}

func (ec *executionContext) marshalNSourceRepository2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx context.Context, sel ast.SelectionSet, v []*models.SourceRepository) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx context.Context, sel ast.SelectionSet, v *models.SourceRepository) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._SourceRepository(ctx, sel, v)
}

func (ec *executionContext) marshalNSourceRepositoryConnection2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryConnection(ctx context.Context, sel ast.SelectionSet, v models.SourceRepositoryConnection) graphql.Marshaler {
	return ec._SourceRepositoryConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSourceRepositoryConnection2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryConnection(ctx context.Context, sel ast.SelectionSet, v *models.SourceRepositoryConnection) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._SourceRepositoryConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSourceRepositoryCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateInput(ctx context.Context, v interface{}) (models.SourceRepositoryCreateInput, error) {
	return ec.unmarshalInputSourceRepositoryCreateInput(ctx, v)
}

func (ec *executionContext) unmarshalNSourceRepositoryCreateInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateInput(ctx context.Context, v interface{}) (*models.SourceRepositoryCreateInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNSourceRepositoryCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNSourceRepositoryCreateOneInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateOneInput(ctx context.Context, v interface{}) (models.SourceRepositoryCreateOneInput, error) {
	return ec.unmarshalInputSourceRepositoryCreateOneInput(ctx, v)
}

func (ec *executionContext) unmarshalNSourceRepositoryCreateOneInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateOneInput(ctx context.Context, v interface{}) (*models.SourceRepositoryCreateOneInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNSourceRepositoryCreateOneInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateOneInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNSourceRepositoryEdge2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryEdge(ctx context.Context, sel ast.SelectionSet, v []*models.SourceRepositoryEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSourceRepositoryEdge2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNSourceRepositorySubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx context.Context, v interface{}) (models.SourceRepositorySubscriptionWhereInput, error) {
	return ec.unmarshalInputSourceRepositorySubscriptionWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNSourceRepositorySubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx context.Context, v interface{}) (*models.SourceRepositorySubscriptionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNSourceRepositorySubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNSourceRepositoryUpdateDataInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateDataInput(ctx context.Context, v interface{}) (models.SourceRepositoryUpdateDataInput, error) {
	return ec.unmarshalInputSourceRepositoryUpdateDataInput(ctx, v)
}

func (ec *executionContext) unmarshalNSourceRepositoryUpdateDataInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateDataInput(ctx context.Context, v interface{}) (*models.SourceRepositoryUpdateDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNSourceRepositoryUpdateDataInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateDataInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNSourceRepositoryUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateInput(ctx context.Context, v interface{}) (models.SourceRepositoryUpdateInput, error) {
	return ec.unmarshalInputSourceRepositoryUpdateInput(ctx, v)
}

func (ec *executionContext) unmarshalNSourceRepositoryUpdateManyMutationInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateManyMutationInput(ctx context.Context, v interface{}) (models.SourceRepositoryUpdateManyMutationInput, error) {
	return ec.unmarshalInputSourceRepositoryUpdateManyMutationInput(ctx, v)
}

func (ec *executionContext) unmarshalNSourceRepositoryWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx context.Context, v interface{}) (models.SourceRepositoryWhereInput, error) {
	return ec.unmarshalInputSourceRepositoryWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNSourceRepositoryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx context.Context, v interface{}) (*models.SourceRepositoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNSourceRepositoryWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNSourceRepositoryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereUniqueInput(ctx context.Context, v interface{}) (models.SourceRepositoryWhereUniqueInput, error) {
	return ec.unmarshalInputSourceRepositoryWhereUniqueInput(ctx, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v []*models.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserConnection2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserConnection(ctx context.Context, sel ast.SelectionSet, v models.UserConnection) graphql.Marshaler {
	return ec._UserConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserConnection2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserConnection(ctx context.Context, sel ast.SelectionSet, v *models.UserConnection) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._UserConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateInput(ctx context.Context, v interface{}) (models.UserCreateInput, error) {
	return ec.unmarshalInputUserCreateInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserCreateInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateInput(ctx context.Context, v interface{}) (*models.UserCreateInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUserCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNUserCreateOneInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateOneInput(ctx context.Context, v interface{}) (models.UserCreateOneInput, error) {
	return ec.unmarshalInputUserCreateOneInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserCreateOneInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateOneInput(ctx context.Context, v interface{}) (*models.UserCreateOneInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUserCreateOneInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateOneInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNUserEdge2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserEdge(ctx context.Context, sel ast.SelectionSet, v []*models.UserEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUserEdge2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNUserSubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx context.Context, v interface{}) (models.UserSubscriptionWhereInput, error) {
	return ec.unmarshalInputUserSubscriptionWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserSubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx context.Context, v interface{}) (*models.UserSubscriptionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUserSubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNUserUpdateDataInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateDataInput(ctx context.Context, v interface{}) (models.UserUpdateDataInput, error) {
	return ec.unmarshalInputUserUpdateDataInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserUpdateDataInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateDataInput(ctx context.Context, v interface{}) (*models.UserUpdateDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUserUpdateDataInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateDataInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNUserUpdateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateInput(ctx context.Context, v interface{}) (models.UserUpdateInput, error) {
	return ec.unmarshalInputUserUpdateInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserUpdateManyMutationInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateManyMutationInput(ctx context.Context, v interface{}) (models.UserUpdateManyMutationInput, error) {
	return ec.unmarshalInputUserUpdateManyMutationInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx context.Context, v interface{}) (models.UserWhereInput, error) {
	return ec.unmarshalInputUserWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalNUserWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx context.Context, v interface{}) (*models.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUserWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNUserWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereUniqueInput(ctx context.Context, v interface{}) (models.UserWhereUniqueInput, error) {
	return ec.unmarshalInputUserWhereUniqueInput(ctx, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOBuildHost2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx context.Context, v interface{}) (models.BuildHost, error) {
	var res models.BuildHost
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOBuildHost2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx context.Context, sel ast.SelectionSet, v models.BuildHost) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOBuildHost2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx context.Context, v interface{}) ([]models.BuildHost, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]models.BuildHost, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNBuildHost2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBuildHost2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx context.Context, sel ast.SelectionSet, v []models.BuildHost) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuildHost2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOBuildHost2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx context.Context, v interface{}) (*models.BuildHost, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBuildHost2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBuildHost2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildHost(ctx context.Context, sel ast.SelectionSet, v *models.BuildHost) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOBuildJob2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx context.Context, sel ast.SelectionSet, v models.BuildJob) graphql.Marshaler {
	return ec._BuildJob(ctx, sel, &v)
}

func (ec *executionContext) marshalOBuildJob2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJob(ctx context.Context, sel ast.SelectionSet, v *models.BuildJob) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BuildJob(ctx, sel, v)
}

func (ec *executionContext) marshalOBuildJobEdge2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobEdge(ctx context.Context, sel ast.SelectionSet, v models.BuildJobEdge) graphql.Marshaler {
	return ec._BuildJobEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalOBuildJobEdge2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobEdge(ctx context.Context, sel ast.SelectionSet, v *models.BuildJobEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BuildJobEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBuildJobOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobOrderByInput(ctx context.Context, v interface{}) (models.BuildJobOrderByInput, error) {
	var res models.BuildJobOrderByInput
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOBuildJobOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobOrderByInput(ctx context.Context, sel ast.SelectionSet, v models.BuildJobOrderByInput) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOBuildJobOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobOrderByInput(ctx context.Context, v interface{}) (*models.BuildJobOrderByInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBuildJobOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobOrderByInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBuildJobOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobOrderByInput(ctx context.Context, sel ast.SelectionSet, v *models.BuildJobOrderByInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOBuildJobPreviousValues2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobPreviousValues(ctx context.Context, sel ast.SelectionSet, v models.BuildJobPreviousValues) graphql.Marshaler {
	return ec._BuildJobPreviousValues(ctx, sel, &v)
}

func (ec *executionContext) marshalOBuildJobPreviousValues2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobPreviousValues(ctx context.Context, sel ast.SelectionSet, v *models.BuildJobPreviousValues) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BuildJobPreviousValues(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBuildJobStatus2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx context.Context, v interface{}) (models.BuildJobStatus, error) {
	var res models.BuildJobStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOBuildJobStatus2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx context.Context, sel ast.SelectionSet, v models.BuildJobStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOBuildJobStatus2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx context.Context, v interface{}) ([]models.BuildJobStatus, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]models.BuildJobStatus, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNBuildJobStatus2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBuildJobStatus2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx context.Context, sel ast.SelectionSet, v []models.BuildJobStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuildJobStatus2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOBuildJobStatus2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx context.Context, v interface{}) (*models.BuildJobStatus, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBuildJobStatus2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBuildJobStatus2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobStatus(ctx context.Context, sel ast.SelectionSet, v *models.BuildJobStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOBuildJobSubscriptionPayload2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionPayload(ctx context.Context, sel ast.SelectionSet, v models.BuildJobSubscriptionPayload) graphql.Marshaler {
	return ec._BuildJobSubscriptionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalOBuildJobSubscriptionPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionPayload(ctx context.Context, sel ast.SelectionSet, v *models.BuildJobSubscriptionPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BuildJobSubscriptionPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBuildJobSubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx context.Context, v interface{}) (models.BuildJobSubscriptionWhereInput, error) {
	return ec.unmarshalInputBuildJobSubscriptionWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalOBuildJobSubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx context.Context, v interface{}) ([]*models.BuildJobSubscriptionWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.BuildJobSubscriptionWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNBuildJobSubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBuildJobSubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx context.Context, v interface{}) (*models.BuildJobSubscriptionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBuildJobSubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobSubscriptionWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOBuildJobWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx context.Context, v interface{}) (models.BuildJobWhereInput, error) {
	return ec.unmarshalInputBuildJobWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalOBuildJobWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx context.Context, v interface{}) ([]*models.BuildJobWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.BuildJobWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNBuildJobWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBuildJobWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx context.Context, v interface{}) (*models.BuildJobWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBuildJobWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐBuildJobWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOCloneStrategy2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx context.Context, v interface{}) (models.CloneStrategy, error) {
	var res models.CloneStrategy
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOCloneStrategy2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx context.Context, sel ast.SelectionSet, v models.CloneStrategy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOCloneStrategy2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx context.Context, v interface{}) ([]models.CloneStrategy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]models.CloneStrategy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNCloneStrategy2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOCloneStrategy2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx context.Context, sel ast.SelectionSet, v []models.CloneStrategy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCloneStrategy2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOCloneStrategy2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx context.Context, v interface{}) (*models.CloneStrategy, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCloneStrategy2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOCloneStrategy2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐCloneStrategy(ctx context.Context, sel ast.SelectionSet, v *models.CloneStrategy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalODateTime2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalODateTime2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalODateTime2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNDateTime2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODateTime2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNDateTime2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalODateTime2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODateTime2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODateTime2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalODateTime2string(ctx, sel, *v)
}

func (ec *executionContext) marshalODockerRegistry2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx context.Context, sel ast.SelectionSet, v models.DockerRegistry) graphql.Marshaler {
	return ec._DockerRegistry(ctx, sel, &v)
}

func (ec *executionContext) marshalODockerRegistry2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistry(ctx context.Context, sel ast.SelectionSet, v *models.DockerRegistry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DockerRegistry(ctx, sel, v)
}

func (ec *executionContext) marshalODockerRegistryEdge2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryEdge(ctx context.Context, sel ast.SelectionSet, v models.DockerRegistryEdge) graphql.Marshaler {
	return ec._DockerRegistryEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalODockerRegistryEdge2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryEdge(ctx context.Context, sel ast.SelectionSet, v *models.DockerRegistryEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DockerRegistryEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalODockerRegistryOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryOrderByInput(ctx context.Context, v interface{}) (models.DockerRegistryOrderByInput, error) {
	var res models.DockerRegistryOrderByInput
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalODockerRegistryOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryOrderByInput(ctx context.Context, sel ast.SelectionSet, v models.DockerRegistryOrderByInput) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalODockerRegistryOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryOrderByInput(ctx context.Context, v interface{}) (*models.DockerRegistryOrderByInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODockerRegistryOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryOrderByInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODockerRegistryOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryOrderByInput(ctx context.Context, sel ast.SelectionSet, v *models.DockerRegistryOrderByInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODockerRegistryPreviousValues2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryPreviousValues(ctx context.Context, sel ast.SelectionSet, v models.DockerRegistryPreviousValues) graphql.Marshaler {
	return ec._DockerRegistryPreviousValues(ctx, sel, &v)
}

func (ec *executionContext) marshalODockerRegistryPreviousValues2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryPreviousValues(ctx context.Context, sel ast.SelectionSet, v *models.DockerRegistryPreviousValues) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DockerRegistryPreviousValues(ctx, sel, v)
}

func (ec *executionContext) marshalODockerRegistrySubscriptionPayload2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionPayload(ctx context.Context, sel ast.SelectionSet, v models.DockerRegistrySubscriptionPayload) graphql.Marshaler {
	return ec._DockerRegistrySubscriptionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalODockerRegistrySubscriptionPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionPayload(ctx context.Context, sel ast.SelectionSet, v *models.DockerRegistrySubscriptionPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DockerRegistrySubscriptionPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalODockerRegistrySubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx context.Context, v interface{}) (models.DockerRegistrySubscriptionWhereInput, error) {
	return ec.unmarshalInputDockerRegistrySubscriptionWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalODockerRegistrySubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx context.Context, v interface{}) ([]*models.DockerRegistrySubscriptionWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.DockerRegistrySubscriptionWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNDockerRegistrySubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODockerRegistrySubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx context.Context, v interface{}) (*models.DockerRegistrySubscriptionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODockerRegistrySubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistrySubscriptionWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalODockerRegistryWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx context.Context, v interface{}) (models.DockerRegistryWhereInput, error) {
	return ec.unmarshalInputDockerRegistryWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalODockerRegistryWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx context.Context, v interface{}) ([]*models.DockerRegistryWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.DockerRegistryWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNDockerRegistryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODockerRegistryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx context.Context, v interface{}) (*models.DockerRegistryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODockerRegistryWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐDockerRegistryWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOMutationType2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx context.Context, v interface{}) ([]models.MutationType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]models.MutationType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNMutationType2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMutationType2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx context.Context, sel ast.SelectionSet, v []models.MutationType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMutationType2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐMutationType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalONode2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐNode(ctx context.Context, sel ast.SelectionSet, v models.Node) graphql.Marshaler {
	return ec._Node(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOSourceProvider2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx context.Context, v interface{}) (models.SourceProvider, error) {
	var res models.SourceProvider
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOSourceProvider2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx context.Context, sel ast.SelectionSet, v models.SourceProvider) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOSourceProvider2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx context.Context, v interface{}) ([]models.SourceProvider, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]models.SourceProvider, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNSourceProvider2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSourceProvider2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx context.Context, sel ast.SelectionSet, v []models.SourceProvider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSourceProvider2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOSourceProvider2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx context.Context, v interface{}) (*models.SourceProvider, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOSourceProvider2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOSourceProvider2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceProvider(ctx context.Context, sel ast.SelectionSet, v *models.SourceProvider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSourceRepository2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx context.Context, sel ast.SelectionSet, v models.SourceRepository) graphql.Marshaler {
	return ec._SourceRepository(ctx, sel, &v)
}

func (ec *executionContext) marshalOSourceRepository2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepository(ctx context.Context, sel ast.SelectionSet, v *models.SourceRepository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SourceRepository(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSourceRepositoryCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateInput(ctx context.Context, v interface{}) (models.SourceRepositoryCreateInput, error) {
	return ec.unmarshalInputSourceRepositoryCreateInput(ctx, v)
}

func (ec *executionContext) unmarshalOSourceRepositoryCreateInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateInput(ctx context.Context, v interface{}) (*models.SourceRepositoryCreateInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOSourceRepositoryCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryCreateInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOSourceRepositoryEdge2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryEdge(ctx context.Context, sel ast.SelectionSet, v models.SourceRepositoryEdge) graphql.Marshaler {
	return ec._SourceRepositoryEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalOSourceRepositoryEdge2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryEdge(ctx context.Context, sel ast.SelectionSet, v *models.SourceRepositoryEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SourceRepositoryEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSourceRepositoryOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryOrderByInput(ctx context.Context, v interface{}) (models.SourceRepositoryOrderByInput, error) {
	var res models.SourceRepositoryOrderByInput
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOSourceRepositoryOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryOrderByInput(ctx context.Context, sel ast.SelectionSet, v models.SourceRepositoryOrderByInput) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOSourceRepositoryOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryOrderByInput(ctx context.Context, v interface{}) (*models.SourceRepositoryOrderByInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOSourceRepositoryOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryOrderByInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOSourceRepositoryOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryOrderByInput(ctx context.Context, sel ast.SelectionSet, v *models.SourceRepositoryOrderByInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSourceRepositoryPreviousValues2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryPreviousValues(ctx context.Context, sel ast.SelectionSet, v models.SourceRepositoryPreviousValues) graphql.Marshaler {
	return ec._SourceRepositoryPreviousValues(ctx, sel, &v)
}

func (ec *executionContext) marshalOSourceRepositoryPreviousValues2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryPreviousValues(ctx context.Context, sel ast.SelectionSet, v *models.SourceRepositoryPreviousValues) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SourceRepositoryPreviousValues(ctx, sel, v)
}

func (ec *executionContext) marshalOSourceRepositorySubscriptionPayload2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionPayload(ctx context.Context, sel ast.SelectionSet, v models.SourceRepositorySubscriptionPayload) graphql.Marshaler {
	return ec._SourceRepositorySubscriptionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalOSourceRepositorySubscriptionPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionPayload(ctx context.Context, sel ast.SelectionSet, v *models.SourceRepositorySubscriptionPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SourceRepositorySubscriptionPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSourceRepositorySubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx context.Context, v interface{}) (models.SourceRepositorySubscriptionWhereInput, error) {
	return ec.unmarshalInputSourceRepositorySubscriptionWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalOSourceRepositorySubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx context.Context, v interface{}) ([]*models.SourceRepositorySubscriptionWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.SourceRepositorySubscriptionWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNSourceRepositorySubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSourceRepositorySubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx context.Context, v interface{}) (*models.SourceRepositorySubscriptionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOSourceRepositorySubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositorySubscriptionWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOSourceRepositoryUpdateDataInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateDataInput(ctx context.Context, v interface{}) (models.SourceRepositoryUpdateDataInput, error) {
	return ec.unmarshalInputSourceRepositoryUpdateDataInput(ctx, v)
}

func (ec *executionContext) unmarshalOSourceRepositoryUpdateDataInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateDataInput(ctx context.Context, v interface{}) (*models.SourceRepositoryUpdateDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOSourceRepositoryUpdateDataInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateDataInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOSourceRepositoryUpdateOneRequiredInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateOneRequiredInput(ctx context.Context, v interface{}) (models.SourceRepositoryUpdateOneRequiredInput, error) {
	return ec.unmarshalInputSourceRepositoryUpdateOneRequiredInput(ctx, v)
}

func (ec *executionContext) unmarshalOSourceRepositoryUpdateOneRequiredInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateOneRequiredInput(ctx context.Context, v interface{}) (*models.SourceRepositoryUpdateOneRequiredInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOSourceRepositoryUpdateOneRequiredInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpdateOneRequiredInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOSourceRepositoryUpsertNestedInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpsertNestedInput(ctx context.Context, v interface{}) (models.SourceRepositoryUpsertNestedInput, error) {
	return ec.unmarshalInputSourceRepositoryUpsertNestedInput(ctx, v)
}

func (ec *executionContext) unmarshalOSourceRepositoryUpsertNestedInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpsertNestedInput(ctx context.Context, v interface{}) (*models.SourceRepositoryUpsertNestedInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOSourceRepositoryUpsertNestedInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryUpsertNestedInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOSourceRepositoryWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx context.Context, v interface{}) (models.SourceRepositoryWhereInput, error) {
	return ec.unmarshalInputSourceRepositoryWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalOSourceRepositoryWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx context.Context, v interface{}) ([]*models.SourceRepositoryWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.SourceRepositoryWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNSourceRepositoryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSourceRepositoryWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx context.Context, v interface{}) (*models.SourceRepositoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOSourceRepositoryWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOSourceRepositoryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereUniqueInput(ctx context.Context, v interface{}) (models.SourceRepositoryWhereUniqueInput, error) {
	return ec.unmarshalInputSourceRepositoryWhereUniqueInput(ctx, v)
}

func (ec *executionContext) unmarshalOSourceRepositoryWhereUniqueInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereUniqueInput(ctx context.Context, v interface{}) (*models.SourceRepositoryWhereUniqueInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOSourceRepositoryWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐSourceRepositoryWhereUniqueInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOUser2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateInput(ctx context.Context, v interface{}) (models.UserCreateInput, error) {
	return ec.unmarshalInputUserCreateInput(ctx, v)
}

func (ec *executionContext) unmarshalOUserCreateInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateInput(ctx context.Context, v interface{}) (*models.UserCreateInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserCreateInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserCreateInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUserEdge2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserEdge(ctx context.Context, sel ast.SelectionSet, v models.UserEdge) graphql.Marshaler {
	return ec._UserEdge(ctx, sel, &v)
}

func (ec *executionContext) marshalOUserEdge2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserEdge(ctx context.Context, sel ast.SelectionSet, v *models.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserOrderByInput(ctx context.Context, v interface{}) (models.UserOrderByInput, error) {
	var res models.UserOrderByInput
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOUserOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserOrderByInput(ctx context.Context, sel ast.SelectionSet, v models.UserOrderByInput) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOUserOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserOrderByInput(ctx context.Context, v interface{}) (*models.UserOrderByInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserOrderByInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserOrderByInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUserOrderByInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserOrderByInput(ctx context.Context, sel ast.SelectionSet, v *models.UserOrderByInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOUserPreviousValues2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserPreviousValues(ctx context.Context, sel ast.SelectionSet, v models.UserPreviousValues) graphql.Marshaler {
	return ec._UserPreviousValues(ctx, sel, &v)
}

func (ec *executionContext) marshalOUserPreviousValues2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserPreviousValues(ctx context.Context, sel ast.SelectionSet, v *models.UserPreviousValues) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserPreviousValues(ctx, sel, v)
}

func (ec *executionContext) marshalOUserSubscriptionPayload2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionPayload(ctx context.Context, sel ast.SelectionSet, v models.UserSubscriptionPayload) graphql.Marshaler {
	return ec._UserSubscriptionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalOUserSubscriptionPayload2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionPayload(ctx context.Context, sel ast.SelectionSet, v *models.UserSubscriptionPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserSubscriptionPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserSubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx context.Context, v interface{}) (models.UserSubscriptionWhereInput, error) {
	return ec.unmarshalInputUserSubscriptionWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalOUserSubscriptionWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx context.Context, v interface{}) ([]*models.UserSubscriptionWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.UserSubscriptionWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUserSubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserSubscriptionWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx context.Context, v interface{}) (*models.UserSubscriptionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserSubscriptionWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserSubscriptionWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUserUpdateDataInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateDataInput(ctx context.Context, v interface{}) (models.UserUpdateDataInput, error) {
	return ec.unmarshalInputUserUpdateDataInput(ctx, v)
}

func (ec *executionContext) unmarshalOUserUpdateDataInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateDataInput(ctx context.Context, v interface{}) (*models.UserUpdateDataInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserUpdateDataInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateDataInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUserUpdateOneRequiredInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateOneRequiredInput(ctx context.Context, v interface{}) (models.UserUpdateOneRequiredInput, error) {
	return ec.unmarshalInputUserUpdateOneRequiredInput(ctx, v)
}

func (ec *executionContext) unmarshalOUserUpdateOneRequiredInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateOneRequiredInput(ctx context.Context, v interface{}) (*models.UserUpdateOneRequiredInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserUpdateOneRequiredInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpdateOneRequiredInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUserUpsertNestedInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpsertNestedInput(ctx context.Context, v interface{}) (models.UserUpsertNestedInput, error) {
	return ec.unmarshalInputUserUpsertNestedInput(ctx, v)
}

func (ec *executionContext) unmarshalOUserUpsertNestedInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpsertNestedInput(ctx context.Context, v interface{}) (*models.UserUpsertNestedInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserUpsertNestedInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserUpsertNestedInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUserWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx context.Context, v interface{}) (models.UserWhereInput, error) {
	return ec.unmarshalInputUserWhereInput(ctx, v)
}

func (ec *executionContext) unmarshalOUserWhereInput2ᚕᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx context.Context, v interface{}) ([]*models.UserWhereInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.UserWhereInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUserWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserWhereInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx context.Context, v interface{}) (*models.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserWhereInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUserWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereUniqueInput(ctx context.Context, v interface{}) (models.UserWhereUniqueInput, error) {
	return ec.unmarshalInputUserWhereUniqueInput(ctx, v)
}

func (ec *executionContext) unmarshalOUserWhereUniqueInput2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereUniqueInput(ctx context.Context, v interface{}) (*models.UserWhereUniqueInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserWhereUniqueInput2githubᚗcomᚋparrotmacᚋlittleblueᚋpkgᚋinternalᚋmodelsᚐUserWhereUniqueInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋparrotmacᚋlittleblueᚋvendorᚋgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
