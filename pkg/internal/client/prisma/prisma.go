// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) BuildJob(params BuildJobWhereUniqueInput) *BuildJobExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BuildJobWhereUniqueInput!", "BuildJob"},
		"buildJob",
		[]string{"id", "createdAt", "updatedAt", "completedAt", "buildHostKind", "buildHostIdentifier", "status", "buildIdentifier", "sourceRevision", "artifactUri", "setupLogs", "buildLogs", "pushLogs"})

	return &BuildJobExec{ret}
}

type BuildJobsParams struct {
	Where   *BuildJobWhereInput   `json:"where,omitempty"`
	OrderBy *BuildJobOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) BuildJobs(params *BuildJobsParams) *BuildJobExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BuildJobWhereInput", "BuildJobOrderByInput", "BuildJob"},
		"buildJobs",
		[]string{"id", "createdAt", "updatedAt", "completedAt", "buildHostKind", "buildHostIdentifier", "status", "buildIdentifier", "sourceRevision", "artifactUri", "setupLogs", "buildLogs", "pushLogs"})

	return &BuildJobExecArray{ret}
}

type BuildJobsConnectionParams struct {
	Where   *BuildJobWhereInput   `json:"where,omitempty"`
	OrderBy *BuildJobOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) BuildJobsConnection(params *BuildJobsConnectionParams) *BuildJobConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BuildJobWhereInput", "BuildJobOrderByInput", "BuildJob"},
		"buildJobsConnection",
		[]string{"edges", "pageInfo"})

	return &BuildJobConnectionExec{ret}
}

func (client *Client) DockerRegistry(params DockerRegistryWhereUniqueInput) *DockerRegistryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"DockerRegistryWhereUniqueInput!", "DockerRegistry"},
		"dockerRegistry",
		[]string{"id", "createdAt", "updatedAt", "Hostname", "AuthUsername", "AuthPassword"})

	return &DockerRegistryExec{ret}
}

type DockerRegistriesParams struct {
	Where   *DockerRegistryWhereInput   `json:"where,omitempty"`
	OrderBy *DockerRegistryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) DockerRegistries(params *DockerRegistriesParams) *DockerRegistryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"DockerRegistryWhereInput", "DockerRegistryOrderByInput", "DockerRegistry"},
		"dockerRegistries",
		[]string{"id", "createdAt", "updatedAt", "Hostname", "AuthUsername", "AuthPassword"})

	return &DockerRegistryExecArray{ret}
}

type DockerRegistriesConnectionParams struct {
	Where   *DockerRegistryWhereInput   `json:"where,omitempty"`
	OrderBy *DockerRegistryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) DockerRegistriesConnection(params *DockerRegistriesConnectionParams) *DockerRegistryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"DockerRegistrieWhereInput", "DockerRegistrieOrderByInput", "DockerRegistrie"},
		"dockerRegistriesConnection",
		[]string{"edges", "pageInfo"})

	return &DockerRegistryConnectionExec{ret}
}

func (client *Client) SourceRepository(params SourceRepositoryWhereUniqueInput) *SourceRepositoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"SourceRepositoryWhereUniqueInput!", "SourceRepository"},
		"sourceRepository",
		[]string{"id", "createdAt", "updatedAt", "sourceProvider", "name", "authClientID", "authSecret", "cloneStrategy", "buildsEnabled", "baseConfigurationFileName"})

	return &SourceRepositoryExec{ret}
}

type SourceRepositoriesParams struct {
	Where   *SourceRepositoryWhereInput   `json:"where,omitempty"`
	OrderBy *SourceRepositoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                        `json:"skip,omitempty"`
	After   *string                       `json:"after,omitempty"`
	Before  *string                       `json:"before,omitempty"`
	First   *int32                        `json:"first,omitempty"`
	Last    *int32                        `json:"last,omitempty"`
}

func (client *Client) SourceRepositories(params *SourceRepositoriesParams) *SourceRepositoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SourceRepositoryWhereInput", "SourceRepositoryOrderByInput", "SourceRepository"},
		"sourceRepositories",
		[]string{"id", "createdAt", "updatedAt", "sourceProvider", "name", "authClientID", "authSecret", "cloneStrategy", "buildsEnabled", "baseConfigurationFileName"})

	return &SourceRepositoryExecArray{ret}
}

type SourceRepositoriesConnectionParams struct {
	Where   *SourceRepositoryWhereInput   `json:"where,omitempty"`
	OrderBy *SourceRepositoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                        `json:"skip,omitempty"`
	After   *string                       `json:"after,omitempty"`
	Before  *string                       `json:"before,omitempty"`
	First   *int32                        `json:"first,omitempty"`
	Last    *int32                        `json:"last,omitempty"`
}

func (client *Client) SourceRepositoriesConnection(params *SourceRepositoriesConnectionParams) *SourceRepositoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SourceRepositorieWhereInput", "SourceRepositorieOrderByInput", "SourceRepositorie"},
		"sourceRepositoriesConnection",
		[]string{"edges", "pageInfo"})

	return &SourceRepositoryConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "createdAt", "updatedAt", "name", "email", "passwordHash", "githubUsername", "githubAccountAuthToken", "googleAccountAuthToken"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "createdAt", "updatedAt", "name", "email", "passwordHash", "githubUsername", "githubAccountAuthToken", "googleAccountAuthToken"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) CreateBuildJob(params BuildJobCreateInput) *BuildJobExec {
	ret := client.Client.Create(
		params,
		[2]string{"BuildJobCreateInput!", "BuildJob"},
		"createBuildJob",
		[]string{"id", "createdAt", "updatedAt", "completedAt", "buildHostKind", "buildHostIdentifier", "status", "buildIdentifier", "sourceRevision", "artifactUri", "setupLogs", "buildLogs", "pushLogs"})

	return &BuildJobExec{ret}
}

type BuildJobUpdateParams struct {
	Data  BuildJobUpdateInput      `json:"data"`
	Where BuildJobWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBuildJob(params BuildJobUpdateParams) *BuildJobExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BuildJobUpdateInput!", "BuildJobWhereUniqueInput!", "BuildJob"},
		"updateBuildJob",
		[]string{"id", "createdAt", "updatedAt", "completedAt", "buildHostKind", "buildHostIdentifier", "status", "buildIdentifier", "sourceRevision", "artifactUri", "setupLogs", "buildLogs", "pushLogs"})

	return &BuildJobExec{ret}
}

type BuildJobUpdateManyParams struct {
	Data  BuildJobUpdateManyMutationInput `json:"data"`
	Where *BuildJobWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBuildJobs(params BuildJobUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BuildJobUpdateManyMutationInput!", "BuildJobWhereInput"},
		"updateManyBuildJobs")
	return &BatchPayloadExec{exec}
}

type BuildJobUpsertParams struct {
	Where  BuildJobWhereUniqueInput `json:"where"`
	Create BuildJobCreateInput      `json:"create"`
	Update BuildJobUpdateInput      `json:"update"`
}

func (client *Client) UpsertBuildJob(params BuildJobUpsertParams) *BuildJobExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BuildJobWhereUniqueInput!", "BuildJobCreateInput!", "BuildJobUpdateInput!", "BuildJob"},
		"upsertBuildJob",
		[]string{"id", "createdAt", "updatedAt", "completedAt", "buildHostKind", "buildHostIdentifier", "status", "buildIdentifier", "sourceRevision", "artifactUri", "setupLogs", "buildLogs", "pushLogs"})

	return &BuildJobExec{ret}
}

func (client *Client) DeleteBuildJob(params BuildJobWhereUniqueInput) *BuildJobExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BuildJobWhereUniqueInput!", "BuildJob"},
		"deleteBuildJob",
		[]string{"id", "createdAt", "updatedAt", "completedAt", "buildHostKind", "buildHostIdentifier", "status", "buildIdentifier", "sourceRevision", "artifactUri", "setupLogs", "buildLogs", "pushLogs"})

	return &BuildJobExec{ret}
}

func (client *Client) DeleteManyBuildJobs(params *BuildJobWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BuildJobWhereInput", "deleteManyBuildJobs")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateDockerRegistry(params DockerRegistryCreateInput) *DockerRegistryExec {
	ret := client.Client.Create(
		params,
		[2]string{"DockerRegistryCreateInput!", "DockerRegistry"},
		"createDockerRegistry",
		[]string{"id", "createdAt", "updatedAt", "Hostname", "AuthUsername", "AuthPassword"})

	return &DockerRegistryExec{ret}
}

type DockerRegistryUpdateParams struct {
	Data  DockerRegistryUpdateInput      `json:"data"`
	Where DockerRegistryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateDockerRegistry(params DockerRegistryUpdateParams) *DockerRegistryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"DockerRegistryUpdateInput!", "DockerRegistryWhereUniqueInput!", "DockerRegistry"},
		"updateDockerRegistry",
		[]string{"id", "createdAt", "updatedAt", "Hostname", "AuthUsername", "AuthPassword"})

	return &DockerRegistryExec{ret}
}

type DockerRegistryUpdateManyParams struct {
	Data  DockerRegistryUpdateManyMutationInput `json:"data"`
	Where *DockerRegistryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyDockerRegistries(params DockerRegistryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"DockerRegistryUpdateManyMutationInput!", "DockerRegistryWhereInput"},
		"updateManyDockerRegistries")
	return &BatchPayloadExec{exec}
}

type DockerRegistryUpsertParams struct {
	Where  DockerRegistryWhereUniqueInput `json:"where"`
	Create DockerRegistryCreateInput      `json:"create"`
	Update DockerRegistryUpdateInput      `json:"update"`
}

func (client *Client) UpsertDockerRegistry(params DockerRegistryUpsertParams) *DockerRegistryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"DockerRegistryWhereUniqueInput!", "DockerRegistryCreateInput!", "DockerRegistryUpdateInput!", "DockerRegistry"},
		"upsertDockerRegistry",
		[]string{"id", "createdAt", "updatedAt", "Hostname", "AuthUsername", "AuthPassword"})

	return &DockerRegistryExec{ret}
}

func (client *Client) DeleteDockerRegistry(params DockerRegistryWhereUniqueInput) *DockerRegistryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"DockerRegistryWhereUniqueInput!", "DockerRegistry"},
		"deleteDockerRegistry",
		[]string{"id", "createdAt", "updatedAt", "Hostname", "AuthUsername", "AuthPassword"})

	return &DockerRegistryExec{ret}
}

func (client *Client) DeleteManyDockerRegistries(params *DockerRegistryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "DockerRegistryWhereInput", "deleteManyDockerRegistries")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateSourceRepository(params SourceRepositoryCreateInput) *SourceRepositoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"SourceRepositoryCreateInput!", "SourceRepository"},
		"createSourceRepository",
		[]string{"id", "createdAt", "updatedAt", "sourceProvider", "name", "authClientID", "authSecret", "cloneStrategy", "buildsEnabled", "baseConfigurationFileName"})

	return &SourceRepositoryExec{ret}
}

type SourceRepositoryUpdateParams struct {
	Data  SourceRepositoryUpdateInput      `json:"data"`
	Where SourceRepositoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateSourceRepository(params SourceRepositoryUpdateParams) *SourceRepositoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"SourceRepositoryUpdateInput!", "SourceRepositoryWhereUniqueInput!", "SourceRepository"},
		"updateSourceRepository",
		[]string{"id", "createdAt", "updatedAt", "sourceProvider", "name", "authClientID", "authSecret", "cloneStrategy", "buildsEnabled", "baseConfigurationFileName"})

	return &SourceRepositoryExec{ret}
}

type SourceRepositoryUpdateManyParams struct {
	Data  SourceRepositoryUpdateManyMutationInput `json:"data"`
	Where *SourceRepositoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManySourceRepositories(params SourceRepositoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"SourceRepositoryUpdateManyMutationInput!", "SourceRepositoryWhereInput"},
		"updateManySourceRepositories")
	return &BatchPayloadExec{exec}
}

type SourceRepositoryUpsertParams struct {
	Where  SourceRepositoryWhereUniqueInput `json:"where"`
	Create SourceRepositoryCreateInput      `json:"create"`
	Update SourceRepositoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertSourceRepository(params SourceRepositoryUpsertParams) *SourceRepositoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"SourceRepositoryWhereUniqueInput!", "SourceRepositoryCreateInput!", "SourceRepositoryUpdateInput!", "SourceRepository"},
		"upsertSourceRepository",
		[]string{"id", "createdAt", "updatedAt", "sourceProvider", "name", "authClientID", "authSecret", "cloneStrategy", "buildsEnabled", "baseConfigurationFileName"})

	return &SourceRepositoryExec{ret}
}

func (client *Client) DeleteSourceRepository(params SourceRepositoryWhereUniqueInput) *SourceRepositoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"SourceRepositoryWhereUniqueInput!", "SourceRepository"},
		"deleteSourceRepository",
		[]string{"id", "createdAt", "updatedAt", "sourceProvider", "name", "authClientID", "authSecret", "cloneStrategy", "buildsEnabled", "baseConfigurationFileName"})

	return &SourceRepositoryExec{ret}
}

func (client *Client) DeleteManySourceRepositories(params *SourceRepositoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "SourceRepositoryWhereInput", "deleteManySourceRepositories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "createdAt", "updatedAt", "name", "email", "passwordHash", "githubUsername", "githubAccountAuthToken", "googleAccountAuthToken"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "createdAt", "updatedAt", "name", "email", "passwordHash", "githubUsername", "githubAccountAuthToken", "googleAccountAuthToken"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "createdAt", "updatedAt", "name", "email", "passwordHash", "githubUsername", "githubAccountAuthToken", "googleAccountAuthToken"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "createdAt", "updatedAt", "name", "email", "passwordHash", "githubUsername", "githubAccountAuthToken", "googleAccountAuthToken"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type BuildJobStatus string

const (
	BuildJobStatusUnknown        BuildJobStatus = "Unknown"
	BuildJobStatusCreated        BuildJobStatus = "Created"
	BuildJobStatusPending        BuildJobStatus = "Pending"
	BuildJobStatusCloning        BuildJobStatus = "Cloning"
	BuildJobStatusPreparingBuild BuildJobStatus = "PreparingBuild"
	BuildJobStatusBuilding       BuildJobStatus = "Building"
	BuildJobStatusPushing        BuildJobStatus = "Pushing"
	BuildJobStatusComplete       BuildJobStatus = "Complete"
)

type BuildJobOrderByInput string

const (
	BuildJobOrderByInputIDAsc                   BuildJobOrderByInput = "id_ASC"
	BuildJobOrderByInputIDDesc                  BuildJobOrderByInput = "id_DESC"
	BuildJobOrderByInputCreatedAtAsc            BuildJobOrderByInput = "createdAt_ASC"
	BuildJobOrderByInputCreatedAtDesc           BuildJobOrderByInput = "createdAt_DESC"
	BuildJobOrderByInputUpdatedAtAsc            BuildJobOrderByInput = "updatedAt_ASC"
	BuildJobOrderByInputUpdatedAtDesc           BuildJobOrderByInput = "updatedAt_DESC"
	BuildJobOrderByInputCompletedAtAsc          BuildJobOrderByInput = "completedAt_ASC"
	BuildJobOrderByInputCompletedAtDesc         BuildJobOrderByInput = "completedAt_DESC"
	BuildJobOrderByInputBuildHostKindAsc        BuildJobOrderByInput = "buildHostKind_ASC"
	BuildJobOrderByInputBuildHostKindDesc       BuildJobOrderByInput = "buildHostKind_DESC"
	BuildJobOrderByInputBuildHostIdentifierAsc  BuildJobOrderByInput = "buildHostIdentifier_ASC"
	BuildJobOrderByInputBuildHostIdentifierDesc BuildJobOrderByInput = "buildHostIdentifier_DESC"
	BuildJobOrderByInputStatusAsc               BuildJobOrderByInput = "status_ASC"
	BuildJobOrderByInputStatusDesc              BuildJobOrderByInput = "status_DESC"
	BuildJobOrderByInputBuildIdentifierAsc      BuildJobOrderByInput = "buildIdentifier_ASC"
	BuildJobOrderByInputBuildIdentifierDesc     BuildJobOrderByInput = "buildIdentifier_DESC"
	BuildJobOrderByInputSourceRevisionAsc       BuildJobOrderByInput = "sourceRevision_ASC"
	BuildJobOrderByInputSourceRevisionDesc      BuildJobOrderByInput = "sourceRevision_DESC"
	BuildJobOrderByInputArtifactUriAsc          BuildJobOrderByInput = "artifactUri_ASC"
	BuildJobOrderByInputArtifactUriDesc         BuildJobOrderByInput = "artifactUri_DESC"
	BuildJobOrderByInputSetupLogsAsc            BuildJobOrderByInput = "setupLogs_ASC"
	BuildJobOrderByInputSetupLogsDesc           BuildJobOrderByInput = "setupLogs_DESC"
	BuildJobOrderByInputBuildLogsAsc            BuildJobOrderByInput = "buildLogs_ASC"
	BuildJobOrderByInputBuildLogsDesc           BuildJobOrderByInput = "buildLogs_DESC"
	BuildJobOrderByInputPushLogsAsc             BuildJobOrderByInput = "pushLogs_ASC"
	BuildJobOrderByInputPushLogsDesc            BuildJobOrderByInput = "pushLogs_DESC"
)

type CloneStrategy string

const (
	CloneStrategyGitSsh   CloneStrategy = "GIT_SSH"
	CloneStrategyGitHttps CloneStrategy = "GIT_HTTPS"
)

type SourceProvider string

const (
	SourceProviderGithub SourceProvider = "Github"
)

type DockerRegistryOrderByInput string

const (
	DockerRegistryOrderByInputIDAsc            DockerRegistryOrderByInput = "id_ASC"
	DockerRegistryOrderByInputIDDesc           DockerRegistryOrderByInput = "id_DESC"
	DockerRegistryOrderByInputCreatedAtAsc     DockerRegistryOrderByInput = "createdAt_ASC"
	DockerRegistryOrderByInputCreatedAtDesc    DockerRegistryOrderByInput = "createdAt_DESC"
	DockerRegistryOrderByInputUpdatedAtAsc     DockerRegistryOrderByInput = "updatedAt_ASC"
	DockerRegistryOrderByInputUpdatedAtDesc    DockerRegistryOrderByInput = "updatedAt_DESC"
	DockerRegistryOrderByInputHostnameAsc      DockerRegistryOrderByInput = "Hostname_ASC"
	DockerRegistryOrderByInputHostnameDesc     DockerRegistryOrderByInput = "Hostname_DESC"
	DockerRegistryOrderByInputAuthUsernameAsc  DockerRegistryOrderByInput = "AuthUsername_ASC"
	DockerRegistryOrderByInputAuthUsernameDesc DockerRegistryOrderByInput = "AuthUsername_DESC"
	DockerRegistryOrderByInputAuthPasswordAsc  DockerRegistryOrderByInput = "AuthPassword_ASC"
	DockerRegistryOrderByInputAuthPasswordDesc DockerRegistryOrderByInput = "AuthPassword_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type SourceRepositoryOrderByInput string

const (
	SourceRepositoryOrderByInputIDAsc                         SourceRepositoryOrderByInput = "id_ASC"
	SourceRepositoryOrderByInputIDDesc                        SourceRepositoryOrderByInput = "id_DESC"
	SourceRepositoryOrderByInputCreatedAtAsc                  SourceRepositoryOrderByInput = "createdAt_ASC"
	SourceRepositoryOrderByInputCreatedAtDesc                 SourceRepositoryOrderByInput = "createdAt_DESC"
	SourceRepositoryOrderByInputUpdatedAtAsc                  SourceRepositoryOrderByInput = "updatedAt_ASC"
	SourceRepositoryOrderByInputUpdatedAtDesc                 SourceRepositoryOrderByInput = "updatedAt_DESC"
	SourceRepositoryOrderByInputSourceProviderAsc             SourceRepositoryOrderByInput = "sourceProvider_ASC"
	SourceRepositoryOrderByInputSourceProviderDesc            SourceRepositoryOrderByInput = "sourceProvider_DESC"
	SourceRepositoryOrderByInputNameAsc                       SourceRepositoryOrderByInput = "name_ASC"
	SourceRepositoryOrderByInputNameDesc                      SourceRepositoryOrderByInput = "name_DESC"
	SourceRepositoryOrderByInputAuthClientIdAsc               SourceRepositoryOrderByInput = "authClientID_ASC"
	SourceRepositoryOrderByInputAuthClientIdDesc              SourceRepositoryOrderByInput = "authClientID_DESC"
	SourceRepositoryOrderByInputAuthSecretAsc                 SourceRepositoryOrderByInput = "authSecret_ASC"
	SourceRepositoryOrderByInputAuthSecretDesc                SourceRepositoryOrderByInput = "authSecret_DESC"
	SourceRepositoryOrderByInputCloneStrategyAsc              SourceRepositoryOrderByInput = "cloneStrategy_ASC"
	SourceRepositoryOrderByInputCloneStrategyDesc             SourceRepositoryOrderByInput = "cloneStrategy_DESC"
	SourceRepositoryOrderByInputBuildsEnabledAsc              SourceRepositoryOrderByInput = "buildsEnabled_ASC"
	SourceRepositoryOrderByInputBuildsEnabledDesc             SourceRepositoryOrderByInput = "buildsEnabled_DESC"
	SourceRepositoryOrderByInputBaseConfigurationFileNameAsc  SourceRepositoryOrderByInput = "baseConfigurationFileName_ASC"
	SourceRepositoryOrderByInputBaseConfigurationFileNameDesc SourceRepositoryOrderByInput = "baseConfigurationFileName_DESC"
)

type BuildHost string

const (
	BuildHostLinuxAmd64   BuildHost = "LINUX_AMD64"
	BuildHostLinuxAarch64 BuildHost = "LINUX_AARCH64"
	BuildHostWindowsAmd64 BuildHost = "WINDOWS_AMD64"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc                      UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc                     UserOrderByInput = "id_DESC"
	UserOrderByInputCreatedAtAsc               UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc              UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc               UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc              UserOrderByInput = "updatedAt_DESC"
	UserOrderByInputNameAsc                    UserOrderByInput = "name_ASC"
	UserOrderByInputNameDesc                   UserOrderByInput = "name_DESC"
	UserOrderByInputEmailAsc                   UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc                  UserOrderByInput = "email_DESC"
	UserOrderByInputPasswordHashAsc            UserOrderByInput = "passwordHash_ASC"
	UserOrderByInputPasswordHashDesc           UserOrderByInput = "passwordHash_DESC"
	UserOrderByInputGithubUsernameAsc          UserOrderByInput = "githubUsername_ASC"
	UserOrderByInputGithubUsernameDesc         UserOrderByInput = "githubUsername_DESC"
	UserOrderByInputGithubAccountAuthTokenAsc  UserOrderByInput = "githubAccountAuthToken_ASC"
	UserOrderByInputGithubAccountAuthTokenDesc UserOrderByInput = "githubAccountAuthToken_DESC"
	UserOrderByInputGoogleAccountAuthTokenAsc  UserOrderByInput = "googleAccountAuthToken_ASC"
	UserOrderByInputGoogleAccountAuthTokenDesc UserOrderByInput = "googleAccountAuthToken_DESC"
)

type DockerRegistryCreateInput struct {
	ID           *string `json:"id,omitempty"`
	Hostname     string  `json:"Hostname"`
	AuthUsername string  `json:"AuthUsername"`
	AuthPassword string  `json:"AuthPassword"`
}

type UserCreateOneInput struct {
	Create  *UserCreateInput      `json:"create,omitempty"`
	Connect *UserWhereUniqueInput `json:"connect,omitempty"`
}

type UserUpsertNestedInput struct {
	Update UserUpdateDataInput `json:"update"`
	Create UserCreateInput     `json:"create"`
}

type BuildJobWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type SourceRepositoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BuildJobWhereInput struct {
	ID                               *string                     `json:"id,omitempty"`
	IDNot                            *string                     `json:"id_not,omitempty"`
	IDIn                             []string                    `json:"id_in,omitempty"`
	IDNotIn                          []string                    `json:"id_not_in,omitempty"`
	IDLt                             *string                     `json:"id_lt,omitempty"`
	IDLte                            *string                     `json:"id_lte,omitempty"`
	IDGt                             *string                     `json:"id_gt,omitempty"`
	IDGte                            *string                     `json:"id_gte,omitempty"`
	IDContains                       *string                     `json:"id_contains,omitempty"`
	IDNotContains                    *string                     `json:"id_not_contains,omitempty"`
	IDStartsWith                     *string                     `json:"id_starts_with,omitempty"`
	IDNotStartsWith                  *string                     `json:"id_not_starts_with,omitempty"`
	IDEndsWith                       *string                     `json:"id_ends_with,omitempty"`
	IDNotEndsWith                    *string                     `json:"id_not_ends_with,omitempty"`
	CreatedAt                        *string                     `json:"createdAt,omitempty"`
	CreatedAtNot                     *string                     `json:"createdAt_not,omitempty"`
	CreatedAtIn                      []string                    `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                   []string                    `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                      *string                     `json:"createdAt_lt,omitempty"`
	CreatedAtLte                     *string                     `json:"createdAt_lte,omitempty"`
	CreatedAtGt                      *string                     `json:"createdAt_gt,omitempty"`
	CreatedAtGte                     *string                     `json:"createdAt_gte,omitempty"`
	UpdatedAt                        *string                     `json:"updatedAt,omitempty"`
	UpdatedAtNot                     *string                     `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                      []string                    `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                   []string                    `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                      *string                     `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                     *string                     `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                      *string                     `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                     *string                     `json:"updatedAt_gte,omitempty"`
	CompletedAt                      *string                     `json:"completedAt,omitempty"`
	CompletedAtNot                   *string                     `json:"completedAt_not,omitempty"`
	CompletedAtIn                    []string                    `json:"completedAt_in,omitempty"`
	CompletedAtNotIn                 []string                    `json:"completedAt_not_in,omitempty"`
	CompletedAtLt                    *string                     `json:"completedAt_lt,omitempty"`
	CompletedAtLte                   *string                     `json:"completedAt_lte,omitempty"`
	CompletedAtGt                    *string                     `json:"completedAt_gt,omitempty"`
	CompletedAtGte                   *string                     `json:"completedAt_gte,omitempty"`
	BuildHostKind                    *BuildHost                  `json:"buildHostKind,omitempty"`
	BuildHostKindNot                 *BuildHost                  `json:"buildHostKind_not,omitempty"`
	BuildHostKindIn                  []BuildHost                 `json:"buildHostKind_in,omitempty"`
	BuildHostKindNotIn               []BuildHost                 `json:"buildHostKind_not_in,omitempty"`
	BuildHostIdentifier              *string                     `json:"buildHostIdentifier,omitempty"`
	BuildHostIdentifierNot           *string                     `json:"buildHostIdentifier_not,omitempty"`
	BuildHostIdentifierIn            []string                    `json:"buildHostIdentifier_in,omitempty"`
	BuildHostIdentifierNotIn         []string                    `json:"buildHostIdentifier_not_in,omitempty"`
	BuildHostIdentifierLt            *string                     `json:"buildHostIdentifier_lt,omitempty"`
	BuildHostIdentifierLte           *string                     `json:"buildHostIdentifier_lte,omitempty"`
	BuildHostIdentifierGt            *string                     `json:"buildHostIdentifier_gt,omitempty"`
	BuildHostIdentifierGte           *string                     `json:"buildHostIdentifier_gte,omitempty"`
	BuildHostIdentifierContains      *string                     `json:"buildHostIdentifier_contains,omitempty"`
	BuildHostIdentifierNotContains   *string                     `json:"buildHostIdentifier_not_contains,omitempty"`
	BuildHostIdentifierStartsWith    *string                     `json:"buildHostIdentifier_starts_with,omitempty"`
	BuildHostIdentifierNotStartsWith *string                     `json:"buildHostIdentifier_not_starts_with,omitempty"`
	BuildHostIdentifierEndsWith      *string                     `json:"buildHostIdentifier_ends_with,omitempty"`
	BuildHostIdentifierNotEndsWith   *string                     `json:"buildHostIdentifier_not_ends_with,omitempty"`
	Repo                             *SourceRepositoryWhereInput `json:"repo,omitempty"`
	Status                           *BuildJobStatus             `json:"status,omitempty"`
	StatusNot                        *BuildJobStatus             `json:"status_not,omitempty"`
	StatusIn                         []BuildJobStatus            `json:"status_in,omitempty"`
	StatusNotIn                      []BuildJobStatus            `json:"status_not_in,omitempty"`
	BuildIdentifier                  *string                     `json:"buildIdentifier,omitempty"`
	BuildIdentifierNot               *string                     `json:"buildIdentifier_not,omitempty"`
	BuildIdentifierIn                []string                    `json:"buildIdentifier_in,omitempty"`
	BuildIdentifierNotIn             []string                    `json:"buildIdentifier_not_in,omitempty"`
	BuildIdentifierLt                *string                     `json:"buildIdentifier_lt,omitempty"`
	BuildIdentifierLte               *string                     `json:"buildIdentifier_lte,omitempty"`
	BuildIdentifierGt                *string                     `json:"buildIdentifier_gt,omitempty"`
	BuildIdentifierGte               *string                     `json:"buildIdentifier_gte,omitempty"`
	BuildIdentifierContains          *string                     `json:"buildIdentifier_contains,omitempty"`
	BuildIdentifierNotContains       *string                     `json:"buildIdentifier_not_contains,omitempty"`
	BuildIdentifierStartsWith        *string                     `json:"buildIdentifier_starts_with,omitempty"`
	BuildIdentifierNotStartsWith     *string                     `json:"buildIdentifier_not_starts_with,omitempty"`
	BuildIdentifierEndsWith          *string                     `json:"buildIdentifier_ends_with,omitempty"`
	BuildIdentifierNotEndsWith       *string                     `json:"buildIdentifier_not_ends_with,omitempty"`
	SourceRevision                   *string                     `json:"sourceRevision,omitempty"`
	SourceRevisionNot                *string                     `json:"sourceRevision_not,omitempty"`
	SourceRevisionIn                 []string                    `json:"sourceRevision_in,omitempty"`
	SourceRevisionNotIn              []string                    `json:"sourceRevision_not_in,omitempty"`
	SourceRevisionLt                 *string                     `json:"sourceRevision_lt,omitempty"`
	SourceRevisionLte                *string                     `json:"sourceRevision_lte,omitempty"`
	SourceRevisionGt                 *string                     `json:"sourceRevision_gt,omitempty"`
	SourceRevisionGte                *string                     `json:"sourceRevision_gte,omitempty"`
	SourceRevisionContains           *string                     `json:"sourceRevision_contains,omitempty"`
	SourceRevisionNotContains        *string                     `json:"sourceRevision_not_contains,omitempty"`
	SourceRevisionStartsWith         *string                     `json:"sourceRevision_starts_with,omitempty"`
	SourceRevisionNotStartsWith      *string                     `json:"sourceRevision_not_starts_with,omitempty"`
	SourceRevisionEndsWith           *string                     `json:"sourceRevision_ends_with,omitempty"`
	SourceRevisionNotEndsWith        *string                     `json:"sourceRevision_not_ends_with,omitempty"`
	ArtifactUri                      *string                     `json:"artifactUri,omitempty"`
	ArtifactUriNot                   *string                     `json:"artifactUri_not,omitempty"`
	ArtifactUriIn                    []string                    `json:"artifactUri_in,omitempty"`
	ArtifactUriNotIn                 []string                    `json:"artifactUri_not_in,omitempty"`
	ArtifactUriLt                    *string                     `json:"artifactUri_lt,omitempty"`
	ArtifactUriLte                   *string                     `json:"artifactUri_lte,omitempty"`
	ArtifactUriGt                    *string                     `json:"artifactUri_gt,omitempty"`
	ArtifactUriGte                   *string                     `json:"artifactUri_gte,omitempty"`
	ArtifactUriContains              *string                     `json:"artifactUri_contains,omitempty"`
	ArtifactUriNotContains           *string                     `json:"artifactUri_not_contains,omitempty"`
	ArtifactUriStartsWith            *string                     `json:"artifactUri_starts_with,omitempty"`
	ArtifactUriNotStartsWith         *string                     `json:"artifactUri_not_starts_with,omitempty"`
	ArtifactUriEndsWith              *string                     `json:"artifactUri_ends_with,omitempty"`
	ArtifactUriNotEndsWith           *string                     `json:"artifactUri_not_ends_with,omitempty"`
	SetupLogs                        *string                     `json:"setupLogs,omitempty"`
	SetupLogsNot                     *string                     `json:"setupLogs_not,omitempty"`
	SetupLogsIn                      []string                    `json:"setupLogs_in,omitempty"`
	SetupLogsNotIn                   []string                    `json:"setupLogs_not_in,omitempty"`
	SetupLogsLt                      *string                     `json:"setupLogs_lt,omitempty"`
	SetupLogsLte                     *string                     `json:"setupLogs_lte,omitempty"`
	SetupLogsGt                      *string                     `json:"setupLogs_gt,omitempty"`
	SetupLogsGte                     *string                     `json:"setupLogs_gte,omitempty"`
	SetupLogsContains                *string                     `json:"setupLogs_contains,omitempty"`
	SetupLogsNotContains             *string                     `json:"setupLogs_not_contains,omitempty"`
	SetupLogsStartsWith              *string                     `json:"setupLogs_starts_with,omitempty"`
	SetupLogsNotStartsWith           *string                     `json:"setupLogs_not_starts_with,omitempty"`
	SetupLogsEndsWith                *string                     `json:"setupLogs_ends_with,omitempty"`
	SetupLogsNotEndsWith             *string                     `json:"setupLogs_not_ends_with,omitempty"`
	BuildLogs                        *string                     `json:"buildLogs,omitempty"`
	BuildLogsNot                     *string                     `json:"buildLogs_not,omitempty"`
	BuildLogsIn                      []string                    `json:"buildLogs_in,omitempty"`
	BuildLogsNotIn                   []string                    `json:"buildLogs_not_in,omitempty"`
	BuildLogsLt                      *string                     `json:"buildLogs_lt,omitempty"`
	BuildLogsLte                     *string                     `json:"buildLogs_lte,omitempty"`
	BuildLogsGt                      *string                     `json:"buildLogs_gt,omitempty"`
	BuildLogsGte                     *string                     `json:"buildLogs_gte,omitempty"`
	BuildLogsContains                *string                     `json:"buildLogs_contains,omitempty"`
	BuildLogsNotContains             *string                     `json:"buildLogs_not_contains,omitempty"`
	BuildLogsStartsWith              *string                     `json:"buildLogs_starts_with,omitempty"`
	BuildLogsNotStartsWith           *string                     `json:"buildLogs_not_starts_with,omitempty"`
	BuildLogsEndsWith                *string                     `json:"buildLogs_ends_with,omitempty"`
	BuildLogsNotEndsWith             *string                     `json:"buildLogs_not_ends_with,omitempty"`
	PushLogs                         *string                     `json:"pushLogs,omitempty"`
	PushLogsNot                      *string                     `json:"pushLogs_not,omitempty"`
	PushLogsIn                       []string                    `json:"pushLogs_in,omitempty"`
	PushLogsNotIn                    []string                    `json:"pushLogs_not_in,omitempty"`
	PushLogsLt                       *string                     `json:"pushLogs_lt,omitempty"`
	PushLogsLte                      *string                     `json:"pushLogs_lte,omitempty"`
	PushLogsGt                       *string                     `json:"pushLogs_gt,omitempty"`
	PushLogsGte                      *string                     `json:"pushLogs_gte,omitempty"`
	PushLogsContains                 *string                     `json:"pushLogs_contains,omitempty"`
	PushLogsNotContains              *string                     `json:"pushLogs_not_contains,omitempty"`
	PushLogsStartsWith               *string                     `json:"pushLogs_starts_with,omitempty"`
	PushLogsNotStartsWith            *string                     `json:"pushLogs_not_starts_with,omitempty"`
	PushLogsEndsWith                 *string                     `json:"pushLogs_ends_with,omitempty"`
	PushLogsNotEndsWith              *string                     `json:"pushLogs_not_ends_with,omitempty"`
	And                              []BuildJobWhereInput        `json:"AND,omitempty"`
	Or                               []BuildJobWhereInput        `json:"OR,omitempty"`
	Not                              []BuildJobWhereInput        `json:"NOT,omitempty"`
}

type DockerRegistrySubscriptionWhereInput struct {
	MutationIn                 []MutationType                         `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                               `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                               `json:"updatedFields_contains_some,omitempty"`
	Node                       *DockerRegistryWhereInput              `json:"node,omitempty"`
	And                        []DockerRegistrySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []DockerRegistrySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []DockerRegistrySubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserWhereInput struct {
	ID                                  *string          `json:"id,omitempty"`
	IDNot                               *string          `json:"id_not,omitempty"`
	IDIn                                []string         `json:"id_in,omitempty"`
	IDNotIn                             []string         `json:"id_not_in,omitempty"`
	IDLt                                *string          `json:"id_lt,omitempty"`
	IDLte                               *string          `json:"id_lte,omitempty"`
	IDGt                                *string          `json:"id_gt,omitempty"`
	IDGte                               *string          `json:"id_gte,omitempty"`
	IDContains                          *string          `json:"id_contains,omitempty"`
	IDNotContains                       *string          `json:"id_not_contains,omitempty"`
	IDStartsWith                        *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith                     *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith                          *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith                       *string          `json:"id_not_ends_with,omitempty"`
	CreatedAt                           *string          `json:"createdAt,omitempty"`
	CreatedAtNot                        *string          `json:"createdAt_not,omitempty"`
	CreatedAtIn                         []string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                      []string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                         *string          `json:"createdAt_lt,omitempty"`
	CreatedAtLte                        *string          `json:"createdAt_lte,omitempty"`
	CreatedAtGt                         *string          `json:"createdAt_gt,omitempty"`
	CreatedAtGte                        *string          `json:"createdAt_gte,omitempty"`
	UpdatedAt                           *string          `json:"updatedAt,omitempty"`
	UpdatedAtNot                        *string          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                         []string         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                      []string         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                         *string          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                        *string          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                         *string          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                        *string          `json:"updatedAt_gte,omitempty"`
	Name                                *string          `json:"name,omitempty"`
	NameNot                             *string          `json:"name_not,omitempty"`
	NameIn                              []string         `json:"name_in,omitempty"`
	NameNotIn                           []string         `json:"name_not_in,omitempty"`
	NameLt                              *string          `json:"name_lt,omitempty"`
	NameLte                             *string          `json:"name_lte,omitempty"`
	NameGt                              *string          `json:"name_gt,omitempty"`
	NameGte                             *string          `json:"name_gte,omitempty"`
	NameContains                        *string          `json:"name_contains,omitempty"`
	NameNotContains                     *string          `json:"name_not_contains,omitempty"`
	NameStartsWith                      *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith                   *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith                        *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith                     *string          `json:"name_not_ends_with,omitempty"`
	Email                               *string          `json:"email,omitempty"`
	EmailNot                            *string          `json:"email_not,omitempty"`
	EmailIn                             []string         `json:"email_in,omitempty"`
	EmailNotIn                          []string         `json:"email_not_in,omitempty"`
	EmailLt                             *string          `json:"email_lt,omitempty"`
	EmailLte                            *string          `json:"email_lte,omitempty"`
	EmailGt                             *string          `json:"email_gt,omitempty"`
	EmailGte                            *string          `json:"email_gte,omitempty"`
	EmailContains                       *string          `json:"email_contains,omitempty"`
	EmailNotContains                    *string          `json:"email_not_contains,omitempty"`
	EmailStartsWith                     *string          `json:"email_starts_with,omitempty"`
	EmailNotStartsWith                  *string          `json:"email_not_starts_with,omitempty"`
	EmailEndsWith                       *string          `json:"email_ends_with,omitempty"`
	EmailNotEndsWith                    *string          `json:"email_not_ends_with,omitempty"`
	PasswordHash                        *string          `json:"passwordHash,omitempty"`
	PasswordHashNot                     *string          `json:"passwordHash_not,omitempty"`
	PasswordHashIn                      []string         `json:"passwordHash_in,omitempty"`
	PasswordHashNotIn                   []string         `json:"passwordHash_not_in,omitempty"`
	PasswordHashLt                      *string          `json:"passwordHash_lt,omitempty"`
	PasswordHashLte                     *string          `json:"passwordHash_lte,omitempty"`
	PasswordHashGt                      *string          `json:"passwordHash_gt,omitempty"`
	PasswordHashGte                     *string          `json:"passwordHash_gte,omitempty"`
	PasswordHashContains                *string          `json:"passwordHash_contains,omitempty"`
	PasswordHashNotContains             *string          `json:"passwordHash_not_contains,omitempty"`
	PasswordHashStartsWith              *string          `json:"passwordHash_starts_with,omitempty"`
	PasswordHashNotStartsWith           *string          `json:"passwordHash_not_starts_with,omitempty"`
	PasswordHashEndsWith                *string          `json:"passwordHash_ends_with,omitempty"`
	PasswordHashNotEndsWith             *string          `json:"passwordHash_not_ends_with,omitempty"`
	GithubUsername                      *string          `json:"githubUsername,omitempty"`
	GithubUsernameNot                   *string          `json:"githubUsername_not,omitempty"`
	GithubUsernameIn                    []string         `json:"githubUsername_in,omitempty"`
	GithubUsernameNotIn                 []string         `json:"githubUsername_not_in,omitempty"`
	GithubUsernameLt                    *string          `json:"githubUsername_lt,omitempty"`
	GithubUsernameLte                   *string          `json:"githubUsername_lte,omitempty"`
	GithubUsernameGt                    *string          `json:"githubUsername_gt,omitempty"`
	GithubUsernameGte                   *string          `json:"githubUsername_gte,omitempty"`
	GithubUsernameContains              *string          `json:"githubUsername_contains,omitempty"`
	GithubUsernameNotContains           *string          `json:"githubUsername_not_contains,omitempty"`
	GithubUsernameStartsWith            *string          `json:"githubUsername_starts_with,omitempty"`
	GithubUsernameNotStartsWith         *string          `json:"githubUsername_not_starts_with,omitempty"`
	GithubUsernameEndsWith              *string          `json:"githubUsername_ends_with,omitempty"`
	GithubUsernameNotEndsWith           *string          `json:"githubUsername_not_ends_with,omitempty"`
	GithubAccountAuthToken              *string          `json:"githubAccountAuthToken,omitempty"`
	GithubAccountAuthTokenNot           *string          `json:"githubAccountAuthToken_not,omitempty"`
	GithubAccountAuthTokenIn            []string         `json:"githubAccountAuthToken_in,omitempty"`
	GithubAccountAuthTokenNotIn         []string         `json:"githubAccountAuthToken_not_in,omitempty"`
	GithubAccountAuthTokenLt            *string          `json:"githubAccountAuthToken_lt,omitempty"`
	GithubAccountAuthTokenLte           *string          `json:"githubAccountAuthToken_lte,omitempty"`
	GithubAccountAuthTokenGt            *string          `json:"githubAccountAuthToken_gt,omitempty"`
	GithubAccountAuthTokenGte           *string          `json:"githubAccountAuthToken_gte,omitempty"`
	GithubAccountAuthTokenContains      *string          `json:"githubAccountAuthToken_contains,omitempty"`
	GithubAccountAuthTokenNotContains   *string          `json:"githubAccountAuthToken_not_contains,omitempty"`
	GithubAccountAuthTokenStartsWith    *string          `json:"githubAccountAuthToken_starts_with,omitempty"`
	GithubAccountAuthTokenNotStartsWith *string          `json:"githubAccountAuthToken_not_starts_with,omitempty"`
	GithubAccountAuthTokenEndsWith      *string          `json:"githubAccountAuthToken_ends_with,omitempty"`
	GithubAccountAuthTokenNotEndsWith   *string          `json:"githubAccountAuthToken_not_ends_with,omitempty"`
	GoogleAccountAuthToken              *string          `json:"googleAccountAuthToken,omitempty"`
	GoogleAccountAuthTokenNot           *string          `json:"googleAccountAuthToken_not,omitempty"`
	GoogleAccountAuthTokenIn            []string         `json:"googleAccountAuthToken_in,omitempty"`
	GoogleAccountAuthTokenNotIn         []string         `json:"googleAccountAuthToken_not_in,omitempty"`
	GoogleAccountAuthTokenLt            *string          `json:"googleAccountAuthToken_lt,omitempty"`
	GoogleAccountAuthTokenLte           *string          `json:"googleAccountAuthToken_lte,omitempty"`
	GoogleAccountAuthTokenGt            *string          `json:"googleAccountAuthToken_gt,omitempty"`
	GoogleAccountAuthTokenGte           *string          `json:"googleAccountAuthToken_gte,omitempty"`
	GoogleAccountAuthTokenContains      *string          `json:"googleAccountAuthToken_contains,omitempty"`
	GoogleAccountAuthTokenNotContains   *string          `json:"googleAccountAuthToken_not_contains,omitempty"`
	GoogleAccountAuthTokenStartsWith    *string          `json:"googleAccountAuthToken_starts_with,omitempty"`
	GoogleAccountAuthTokenNotStartsWith *string          `json:"googleAccountAuthToken_not_starts_with,omitempty"`
	GoogleAccountAuthTokenEndsWith      *string          `json:"googleAccountAuthToken_ends_with,omitempty"`
	GoogleAccountAuthTokenNotEndsWith   *string          `json:"googleAccountAuthToken_not_ends_with,omitempty"`
	And                                 []UserWhereInput `json:"AND,omitempty"`
	Or                                  []UserWhereInput `json:"OR,omitempty"`
	Not                                 []UserWhereInput `json:"NOT,omitempty"`
}

type UserUpdateDataInput struct {
	Name                   *string `json:"name,omitempty"`
	Email                  *string `json:"email,omitempty"`
	PasswordHash           *string `json:"passwordHash,omitempty"`
	GithubUsername         *string `json:"githubUsername,omitempty"`
	GithubAccountAuthToken *string `json:"githubAccountAuthToken,omitempty"`
	GoogleAccountAuthToken *string `json:"googleAccountAuthToken,omitempty"`
}

type UserUpdateInput struct {
	Name                   *string `json:"name,omitempty"`
	Email                  *string `json:"email,omitempty"`
	PasswordHash           *string `json:"passwordHash,omitempty"`
	GithubUsername         *string `json:"githubUsername,omitempty"`
	GithubAccountAuthToken *string `json:"githubAccountAuthToken,omitempty"`
	GoogleAccountAuthToken *string `json:"googleAccountAuthToken,omitempty"`
}

type UserUpdateOneRequiredInput struct {
	Create  *UserCreateInput       `json:"create,omitempty"`
	Update  *UserUpdateDataInput   `json:"update,omitempty"`
	Upsert  *UserUpsertNestedInput `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput  `json:"connect,omitempty"`
}

type SourceRepositoryUpdateInput struct {
	Owner                     *UserUpdateOneRequiredInput `json:"owner,omitempty"`
	SourceProvider            *SourceProvider             `json:"sourceProvider,omitempty"`
	Name                      *string                     `json:"name,omitempty"`
	AuthClientId              *string                     `json:"authClientID,omitempty"`
	AuthSecret                *string                     `json:"authSecret,omitempty"`
	CloneStrategy             *CloneStrategy              `json:"cloneStrategy,omitempty"`
	BuildsEnabled             *bool                       `json:"buildsEnabled,omitempty"`
	BaseConfigurationFileName *string                     `json:"baseConfigurationFileName,omitempty"`
}

type SourceRepositoryUpdateDataInput struct {
	Owner                     *UserUpdateOneRequiredInput `json:"owner,omitempty"`
	SourceProvider            *SourceProvider             `json:"sourceProvider,omitempty"`
	Name                      *string                     `json:"name,omitempty"`
	AuthClientId              *string                     `json:"authClientID,omitempty"`
	AuthSecret                *string                     `json:"authSecret,omitempty"`
	CloneStrategy             *CloneStrategy              `json:"cloneStrategy,omitempty"`
	BuildsEnabled             *bool                       `json:"buildsEnabled,omitempty"`
	BaseConfigurationFileName *string                     `json:"baseConfigurationFileName,omitempty"`
}

type DockerRegistryUpdateInput struct {
	Hostname     *string `json:"Hostname,omitempty"`
	AuthUsername *string `json:"AuthUsername,omitempty"`
	AuthPassword *string `json:"AuthPassword,omitempty"`
}

type UserWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type SourceRepositorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                           `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                  `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                 `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                 `json:"updatedFields_contains_some,omitempty"`
	Node                       *SourceRepositoryWhereInput              `json:"node,omitempty"`
	And                        []SourceRepositorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []SourceRepositorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []SourceRepositorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type BuildJobSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *BuildJobWhereInput              `json:"node,omitempty"`
	And                        []BuildJobSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BuildJobSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BuildJobSubscriptionWhereInput `json:"NOT,omitempty"`
}

type SourceRepositoryUpdateOneRequiredInput struct {
	Create  *SourceRepositoryCreateInput       `json:"create,omitempty"`
	Update  *SourceRepositoryUpdateDataInput   `json:"update,omitempty"`
	Upsert  *SourceRepositoryUpsertNestedInput `json:"upsert,omitempty"`
	Connect *SourceRepositoryWhereUniqueInput  `json:"connect,omitempty"`
}

type SourceRepositoryUpsertNestedInput struct {
	Update SourceRepositoryUpdateDataInput `json:"update"`
	Create SourceRepositoryCreateInput     `json:"create"`
}

type BuildJobUpdateInput struct {
	CompletedAt         *string                                 `json:"completedAt,omitempty"`
	BuildHostKind       *BuildHost                              `json:"buildHostKind,omitempty"`
	BuildHostIdentifier *string                                 `json:"buildHostIdentifier,omitempty"`
	Repo                *SourceRepositoryUpdateOneRequiredInput `json:"repo,omitempty"`
	Status              *BuildJobStatus                         `json:"status,omitempty"`
	BuildIdentifier     *string                                 `json:"buildIdentifier,omitempty"`
	SourceRevision      *string                                 `json:"sourceRevision,omitempty"`
	ArtifactUri         *string                                 `json:"artifactUri,omitempty"`
	SetupLogs           *string                                 `json:"setupLogs,omitempty"`
	BuildLogs           *string                                 `json:"buildLogs,omitempty"`
	PushLogs            *string                                 `json:"pushLogs,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Name                   *string `json:"name,omitempty"`
	Email                  *string `json:"email,omitempty"`
	PasswordHash           *string `json:"passwordHash,omitempty"`
	GithubUsername         *string `json:"githubUsername,omitempty"`
	GithubAccountAuthToken *string `json:"githubAccountAuthToken,omitempty"`
	GoogleAccountAuthToken *string `json:"googleAccountAuthToken,omitempty"`
}

type UserCreateInput struct {
	ID                     *string `json:"id,omitempty"`
	Name                   string  `json:"name"`
	Email                  string  `json:"email"`
	PasswordHash           *string `json:"passwordHash,omitempty"`
	GithubUsername         *string `json:"githubUsername,omitempty"`
	GithubAccountAuthToken *string `json:"githubAccountAuthToken,omitempty"`
	GoogleAccountAuthToken *string `json:"googleAccountAuthToken,omitempty"`
}

type DockerRegistryUpdateManyMutationInput struct {
	Hostname     *string `json:"Hostname,omitempty"`
	AuthUsername *string `json:"AuthUsername,omitempty"`
	AuthPassword *string `json:"AuthPassword,omitempty"`
}

type DockerRegistryWhereInput struct {
	ID                        *string                    `json:"id,omitempty"`
	IDNot                     *string                    `json:"id_not,omitempty"`
	IDIn                      []string                   `json:"id_in,omitempty"`
	IDNotIn                   []string                   `json:"id_not_in,omitempty"`
	IDLt                      *string                    `json:"id_lt,omitempty"`
	IDLte                     *string                    `json:"id_lte,omitempty"`
	IDGt                      *string                    `json:"id_gt,omitempty"`
	IDGte                     *string                    `json:"id_gte,omitempty"`
	IDContains                *string                    `json:"id_contains,omitempty"`
	IDNotContains             *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith              *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string                    `json:"id_not_ends_with,omitempty"`
	CreatedAt                 *string                    `json:"createdAt,omitempty"`
	CreatedAtNot              *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string                    `json:"createdAt_gte,omitempty"`
	UpdatedAt                 *string                    `json:"updatedAt,omitempty"`
	UpdatedAtNot              *string                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn               []string                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn            []string                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt               *string                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte              *string                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt               *string                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte              *string                    `json:"updatedAt_gte,omitempty"`
	Hostname                  *string                    `json:"Hostname,omitempty"`
	HostnameNot               *string                    `json:"Hostname_not,omitempty"`
	HostnameIn                []string                   `json:"Hostname_in,omitempty"`
	HostnameNotIn             []string                   `json:"Hostname_not_in,omitempty"`
	HostnameLt                *string                    `json:"Hostname_lt,omitempty"`
	HostnameLte               *string                    `json:"Hostname_lte,omitempty"`
	HostnameGt                *string                    `json:"Hostname_gt,omitempty"`
	HostnameGte               *string                    `json:"Hostname_gte,omitempty"`
	HostnameContains          *string                    `json:"Hostname_contains,omitempty"`
	HostnameNotContains       *string                    `json:"Hostname_not_contains,omitempty"`
	HostnameStartsWith        *string                    `json:"Hostname_starts_with,omitempty"`
	HostnameNotStartsWith     *string                    `json:"Hostname_not_starts_with,omitempty"`
	HostnameEndsWith          *string                    `json:"Hostname_ends_with,omitempty"`
	HostnameNotEndsWith       *string                    `json:"Hostname_not_ends_with,omitempty"`
	AuthUsername              *string                    `json:"AuthUsername,omitempty"`
	AuthUsernameNot           *string                    `json:"AuthUsername_not,omitempty"`
	AuthUsernameIn            []string                   `json:"AuthUsername_in,omitempty"`
	AuthUsernameNotIn         []string                   `json:"AuthUsername_not_in,omitempty"`
	AuthUsernameLt            *string                    `json:"AuthUsername_lt,omitempty"`
	AuthUsernameLte           *string                    `json:"AuthUsername_lte,omitempty"`
	AuthUsernameGt            *string                    `json:"AuthUsername_gt,omitempty"`
	AuthUsernameGte           *string                    `json:"AuthUsername_gte,omitempty"`
	AuthUsernameContains      *string                    `json:"AuthUsername_contains,omitempty"`
	AuthUsernameNotContains   *string                    `json:"AuthUsername_not_contains,omitempty"`
	AuthUsernameStartsWith    *string                    `json:"AuthUsername_starts_with,omitempty"`
	AuthUsernameNotStartsWith *string                    `json:"AuthUsername_not_starts_with,omitempty"`
	AuthUsernameEndsWith      *string                    `json:"AuthUsername_ends_with,omitempty"`
	AuthUsernameNotEndsWith   *string                    `json:"AuthUsername_not_ends_with,omitempty"`
	AuthPassword              *string                    `json:"AuthPassword,omitempty"`
	AuthPasswordNot           *string                    `json:"AuthPassword_not,omitempty"`
	AuthPasswordIn            []string                   `json:"AuthPassword_in,omitempty"`
	AuthPasswordNotIn         []string                   `json:"AuthPassword_not_in,omitempty"`
	AuthPasswordLt            *string                    `json:"AuthPassword_lt,omitempty"`
	AuthPasswordLte           *string                    `json:"AuthPassword_lte,omitempty"`
	AuthPasswordGt            *string                    `json:"AuthPassword_gt,omitempty"`
	AuthPasswordGte           *string                    `json:"AuthPassword_gte,omitempty"`
	AuthPasswordContains      *string                    `json:"AuthPassword_contains,omitempty"`
	AuthPasswordNotContains   *string                    `json:"AuthPassword_not_contains,omitempty"`
	AuthPasswordStartsWith    *string                    `json:"AuthPassword_starts_with,omitempty"`
	AuthPasswordNotStartsWith *string                    `json:"AuthPassword_not_starts_with,omitempty"`
	AuthPasswordEndsWith      *string                    `json:"AuthPassword_ends_with,omitempty"`
	AuthPasswordNotEndsWith   *string                    `json:"AuthPassword_not_ends_with,omitempty"`
	And                       []DockerRegistryWhereInput `json:"AND,omitempty"`
	Or                        []DockerRegistryWhereInput `json:"OR,omitempty"`
	Not                       []DockerRegistryWhereInput `json:"NOT,omitempty"`
}

type SourceRepositoryCreateInput struct {
	ID                        *string            `json:"id,omitempty"`
	Owner                     UserCreateOneInput `json:"owner"`
	SourceProvider            *SourceProvider    `json:"sourceProvider,omitempty"`
	Name                      string             `json:"name"`
	AuthClientId              *string            `json:"authClientID,omitempty"`
	AuthSecret                *string            `json:"authSecret,omitempty"`
	CloneStrategy             CloneStrategy      `json:"cloneStrategy"`
	BuildsEnabled             *bool              `json:"buildsEnabled,omitempty"`
	BaseConfigurationFileName *string            `json:"baseConfigurationFileName,omitempty"`
}

type SourceRepositoryCreateOneInput struct {
	Create  *SourceRepositoryCreateInput      `json:"create,omitempty"`
	Connect *SourceRepositoryWhereUniqueInput `json:"connect,omitempty"`
}

type BuildJobCreateInput struct {
	ID                  *string                        `json:"id,omitempty"`
	CompletedAt         *string                        `json:"completedAt,omitempty"`
	BuildHostKind       BuildHost                      `json:"buildHostKind"`
	BuildHostIdentifier *string                        `json:"buildHostIdentifier,omitempty"`
	Repo                SourceRepositoryCreateOneInput `json:"repo"`
	Status              BuildJobStatus                 `json:"status"`
	BuildIdentifier     string                         `json:"buildIdentifier"`
	SourceRevision      string                         `json:"sourceRevision"`
	ArtifactUri         string                         `json:"artifactUri"`
	SetupLogs           *string                        `json:"setupLogs,omitempty"`
	BuildLogs           *string                        `json:"buildLogs,omitempty"`
	PushLogs            *string                        `json:"pushLogs,omitempty"`
}

type BuildJobUpdateManyMutationInput struct {
	CompletedAt         *string         `json:"completedAt,omitempty"`
	BuildHostKind       *BuildHost      `json:"buildHostKind,omitempty"`
	BuildHostIdentifier *string         `json:"buildHostIdentifier,omitempty"`
	Status              *BuildJobStatus `json:"status,omitempty"`
	BuildIdentifier     *string         `json:"buildIdentifier,omitempty"`
	SourceRevision      *string         `json:"sourceRevision,omitempty"`
	ArtifactUri         *string         `json:"artifactUri,omitempty"`
	SetupLogs           *string         `json:"setupLogs,omitempty"`
	BuildLogs           *string         `json:"buildLogs,omitempty"`
	PushLogs            *string         `json:"pushLogs,omitempty"`
}

type DockerRegistryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type SourceRepositoryUpdateManyMutationInput struct {
	SourceProvider            *SourceProvider `json:"sourceProvider,omitempty"`
	Name                      *string         `json:"name,omitempty"`
	AuthClientId              *string         `json:"authClientID,omitempty"`
	AuthSecret                *string         `json:"authSecret,omitempty"`
	CloneStrategy             *CloneStrategy  `json:"cloneStrategy,omitempty"`
	BuildsEnabled             *bool           `json:"buildsEnabled,omitempty"`
	BaseConfigurationFileName *string         `json:"baseConfigurationFileName,omitempty"`
}

type SourceRepositoryWhereInput struct {
	ID                                     *string                      `json:"id,omitempty"`
	IDNot                                  *string                      `json:"id_not,omitempty"`
	IDIn                                   []string                     `json:"id_in,omitempty"`
	IDNotIn                                []string                     `json:"id_not_in,omitempty"`
	IDLt                                   *string                      `json:"id_lt,omitempty"`
	IDLte                                  *string                      `json:"id_lte,omitempty"`
	IDGt                                   *string                      `json:"id_gt,omitempty"`
	IDGte                                  *string                      `json:"id_gte,omitempty"`
	IDContains                             *string                      `json:"id_contains,omitempty"`
	IDNotContains                          *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith                           *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith                        *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith                             *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith                          *string                      `json:"id_not_ends_with,omitempty"`
	CreatedAt                              *string                      `json:"createdAt,omitempty"`
	CreatedAtNot                           *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn                            []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                         []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                            *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte                           *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt                            *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte                           *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt                              *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot                           *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                            []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                         []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                            *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                           *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                            *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                           *string                      `json:"updatedAt_gte,omitempty"`
	Owner                                  *UserWhereInput              `json:"owner,omitempty"`
	SourceProvider                         *SourceProvider              `json:"sourceProvider,omitempty"`
	SourceProviderNot                      *SourceProvider              `json:"sourceProvider_not,omitempty"`
	SourceProviderIn                       []SourceProvider             `json:"sourceProvider_in,omitempty"`
	SourceProviderNotIn                    []SourceProvider             `json:"sourceProvider_not_in,omitempty"`
	Name                                   *string                      `json:"name,omitempty"`
	NameNot                                *string                      `json:"name_not,omitempty"`
	NameIn                                 []string                     `json:"name_in,omitempty"`
	NameNotIn                              []string                     `json:"name_not_in,omitempty"`
	NameLt                                 *string                      `json:"name_lt,omitempty"`
	NameLte                                *string                      `json:"name_lte,omitempty"`
	NameGt                                 *string                      `json:"name_gt,omitempty"`
	NameGte                                *string                      `json:"name_gte,omitempty"`
	NameContains                           *string                      `json:"name_contains,omitempty"`
	NameNotContains                        *string                      `json:"name_not_contains,omitempty"`
	NameStartsWith                         *string                      `json:"name_starts_with,omitempty"`
	NameNotStartsWith                      *string                      `json:"name_not_starts_with,omitempty"`
	NameEndsWith                           *string                      `json:"name_ends_with,omitempty"`
	NameNotEndsWith                        *string                      `json:"name_not_ends_with,omitempty"`
	AuthClientId                           *string                      `json:"authClientID,omitempty"`
	AuthClientIdNot                        *string                      `json:"authClientID_not,omitempty"`
	AuthClientIdIn                         []string                     `json:"authClientID_in,omitempty"`
	AuthClientIdNotIn                      []string                     `json:"authClientID_not_in,omitempty"`
	AuthClientIdLt                         *string                      `json:"authClientID_lt,omitempty"`
	AuthClientIdLte                        *string                      `json:"authClientID_lte,omitempty"`
	AuthClientIdGt                         *string                      `json:"authClientID_gt,omitempty"`
	AuthClientIdGte                        *string                      `json:"authClientID_gte,omitempty"`
	AuthClientIdContains                   *string                      `json:"authClientID_contains,omitempty"`
	AuthClientIdNotContains                *string                      `json:"authClientID_not_contains,omitempty"`
	AuthClientIdStartsWith                 *string                      `json:"authClientID_starts_with,omitempty"`
	AuthClientIdNotStartsWith              *string                      `json:"authClientID_not_starts_with,omitempty"`
	AuthClientIdEndsWith                   *string                      `json:"authClientID_ends_with,omitempty"`
	AuthClientIdNotEndsWith                *string                      `json:"authClientID_not_ends_with,omitempty"`
	AuthSecret                             *string                      `json:"authSecret,omitempty"`
	AuthSecretNot                          *string                      `json:"authSecret_not,omitempty"`
	AuthSecretIn                           []string                     `json:"authSecret_in,omitempty"`
	AuthSecretNotIn                        []string                     `json:"authSecret_not_in,omitempty"`
	AuthSecretLt                           *string                      `json:"authSecret_lt,omitempty"`
	AuthSecretLte                          *string                      `json:"authSecret_lte,omitempty"`
	AuthSecretGt                           *string                      `json:"authSecret_gt,omitempty"`
	AuthSecretGte                          *string                      `json:"authSecret_gte,omitempty"`
	AuthSecretContains                     *string                      `json:"authSecret_contains,omitempty"`
	AuthSecretNotContains                  *string                      `json:"authSecret_not_contains,omitempty"`
	AuthSecretStartsWith                   *string                      `json:"authSecret_starts_with,omitempty"`
	AuthSecretNotStartsWith                *string                      `json:"authSecret_not_starts_with,omitempty"`
	AuthSecretEndsWith                     *string                      `json:"authSecret_ends_with,omitempty"`
	AuthSecretNotEndsWith                  *string                      `json:"authSecret_not_ends_with,omitempty"`
	CloneStrategy                          *CloneStrategy               `json:"cloneStrategy,omitempty"`
	CloneStrategyNot                       *CloneStrategy               `json:"cloneStrategy_not,omitempty"`
	CloneStrategyIn                        []CloneStrategy              `json:"cloneStrategy_in,omitempty"`
	CloneStrategyNotIn                     []CloneStrategy              `json:"cloneStrategy_not_in,omitempty"`
	BuildsEnabled                          *bool                        `json:"buildsEnabled,omitempty"`
	BuildsEnabledNot                       *bool                        `json:"buildsEnabled_not,omitempty"`
	BaseConfigurationFileName              *string                      `json:"baseConfigurationFileName,omitempty"`
	BaseConfigurationFileNameNot           *string                      `json:"baseConfigurationFileName_not,omitempty"`
	BaseConfigurationFileNameIn            []string                     `json:"baseConfigurationFileName_in,omitempty"`
	BaseConfigurationFileNameNotIn         []string                     `json:"baseConfigurationFileName_not_in,omitempty"`
	BaseConfigurationFileNameLt            *string                      `json:"baseConfigurationFileName_lt,omitempty"`
	BaseConfigurationFileNameLte           *string                      `json:"baseConfigurationFileName_lte,omitempty"`
	BaseConfigurationFileNameGt            *string                      `json:"baseConfigurationFileName_gt,omitempty"`
	BaseConfigurationFileNameGte           *string                      `json:"baseConfigurationFileName_gte,omitempty"`
	BaseConfigurationFileNameContains      *string                      `json:"baseConfigurationFileName_contains,omitempty"`
	BaseConfigurationFileNameNotContains   *string                      `json:"baseConfigurationFileName_not_contains,omitempty"`
	BaseConfigurationFileNameStartsWith    *string                      `json:"baseConfigurationFileName_starts_with,omitempty"`
	BaseConfigurationFileNameNotStartsWith *string                      `json:"baseConfigurationFileName_not_starts_with,omitempty"`
	BaseConfigurationFileNameEndsWith      *string                      `json:"baseConfigurationFileName_ends_with,omitempty"`
	BaseConfigurationFileNameNotEndsWith   *string                      `json:"baseConfigurationFileName_not_ends_with,omitempty"`
	And                                    []SourceRepositoryWhereInput `json:"AND,omitempty"`
	Or                                     []SourceRepositoryWhereInput `json:"OR,omitempty"`
	Not                                    []SourceRepositoryWhereInput `json:"NOT,omitempty"`
}

type BuildJobConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BuildJobConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BuildJobConnectionExec) Edges() *BuildJobEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BuildJobWhereInput", "BuildJobOrderByInput", "BuildJobEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "BuildJob"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &BuildJobEdgeExecArray{nodes}
}

func (instance *BuildJobConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBuildJob"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BuildJobConnectionExec) Exec(ctx context.Context) (*BuildJobConnection, error) {
	var v BuildJobConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BuildJobConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BuildJobConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BuildJobConnectionExecArray) Exec(ctx context.Context) ([]BuildJobConnection, error) {
	var v []BuildJobConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BuildJobConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []BuildJobEdge `json:"edges"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserPreviousValues struct {
	ID                     string  `json:"id"`
	CreatedAt              string  `json:"createdAt"`
	UpdatedAt              string  `json:"updatedAt"`
	Name                   string  `json:"name"`
	Email                  string  `json:"email"`
	PasswordHash           *string `json:"passwordHash,omitempty"`
	GithubUsername         *string `json:"githubUsername,omitempty"`
	GithubAccountAuthToken *string `json:"githubAccountAuthToken,omitempty"`
	GoogleAccountAuthToken *string `json:"googleAccountAuthToken,omitempty"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type SourceRepositorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *SourceRepositorySubscriptionPayloadExec) Node() *SourceRepositoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SourceRepository"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "sourceProvider", "name", "authClientID", "authSecret", "cloneStrategy", "buildsEnabled", "baseConfigurationFileName"})

	return &SourceRepositoryExec{ret}
}

func (instance *SourceRepositorySubscriptionPayloadExec) PreviousValues() *SourceRepositoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SourceRepositoryPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "sourceProvider", "name", "authClientID", "authSecret", "cloneStrategy", "buildsEnabled", "baseConfigurationFileName"})

	return &SourceRepositoryPreviousValuesExec{ret}
}

func (instance SourceRepositorySubscriptionPayloadExec) Exec(ctx context.Context) (*SourceRepositorySubscriptionPayload, error) {
	var v SourceRepositorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SourceRepositorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SourceRepositorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance SourceRepositorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]SourceRepositorySubscriptionPayload, error) {
	var v []SourceRepositorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SourceRepositorySubscriptionPayload struct {
	Mutation      MutationType      `json:"mutation"`
	Node          *SourceRepository `json:"node,omitempty"`
	UpdatedFields []string          `json:"updatedFields,omitempty"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "email", "passwordHash", "githubUsername", "githubAccountAuthToken", "googleAccountAuthToken"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "User"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	var v UserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}

type SourceRepositoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *SourceRepositoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *SourceRepositoryConnectionExec) Edges() *SourceRepositoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"SourceRepositoryWhereInput", "SourceRepositoryOrderByInput", "SourceRepositoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "SourceRepository"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &SourceRepositoryEdgeExecArray{nodes}
}

func (instance *SourceRepositoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateSourceRepository"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance SourceRepositoryConnectionExec) Exec(ctx context.Context) (*SourceRepositoryConnection, error) {
	var v SourceRepositoryConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SourceRepositoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SourceRepositoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance SourceRepositoryConnectionExecArray) Exec(ctx context.Context) ([]SourceRepositoryConnection, error) {
	var v []SourceRepositoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SourceRepositoryConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []SourceRepositoryEdge `json:"edges"`
}

type BuildJobExec struct {
	exec *prisma.Exec
}

func (instance *BuildJobExec) Repo() *SourceRepositoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SourceRepository"},
		"repo",
		[]string{"id", "createdAt", "updatedAt", "sourceProvider", "name", "authClientID", "authSecret", "cloneStrategy", "buildsEnabled", "baseConfigurationFileName"})

	return &SourceRepositoryExec{ret}
}

func (instance BuildJobExec) Exec(ctx context.Context) (*BuildJob, error) {
	var v BuildJob
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BuildJobExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BuildJobExecArray struct {
	exec *prisma.Exec
}

func (instance BuildJobExecArray) Exec(ctx context.Context) ([]BuildJob, error) {
	var v []BuildJob
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BuildJob struct {
	ID                  string         `json:"id"`
	CreatedAt           string         `json:"createdAt"`
	UpdatedAt           string         `json:"updatedAt"`
	CompletedAt         *string        `json:"completedAt,omitempty"`
	BuildHostKind       BuildHost      `json:"buildHostKind"`
	BuildHostIdentifier *string        `json:"buildHostIdentifier,omitempty"`
	Status              BuildJobStatus `json:"status"`
	BuildIdentifier     string         `json:"buildIdentifier"`
	SourceRevision      string         `json:"sourceRevision"`
	ArtifactUri         string         `json:"artifactUri"`
	SetupLogs           *string        `json:"setupLogs,omitempty"`
	BuildLogs           *string        `json:"buildLogs,omitempty"`
	PushLogs            *string        `json:"pushLogs,omitempty"`
}

type DockerRegistryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *DockerRegistryEdgeExec) Node() *DockerRegistryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "DockerRegistry"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "Hostname", "AuthUsername", "AuthPassword"})

	return &DockerRegistryExec{ret}
}

func (instance DockerRegistryEdgeExec) Exec(ctx context.Context) (*DockerRegistryEdge, error) {
	var v DockerRegistryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DockerRegistryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DockerRegistryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance DockerRegistryEdgeExecArray) Exec(ctx context.Context) ([]DockerRegistryEdge, error) {
	var v []DockerRegistryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DockerRegistryEdge struct {
	Node   DockerRegistry `json:"node"`
	Cursor string         `json:"cursor"`
}

type UserExec struct {
	exec *prisma.Exec
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type User struct {
	ID                     string  `json:"id"`
	CreatedAt              string  `json:"createdAt"`
	UpdatedAt              string  `json:"updatedAt"`
	Name                   string  `json:"name"`
	Email                  string  `json:"email"`
	PasswordHash           *string `json:"passwordHash,omitempty"`
	GithubUsername         *string `json:"githubUsername,omitempty"`
	GithubAccountAuthToken *string `json:"githubAccountAuthToken,omitempty"`
	GoogleAccountAuthToken *string `json:"googleAccountAuthToken,omitempty"`
}

type SourceRepositoryExec struct {
	exec *prisma.Exec
}

func (instance *SourceRepositoryExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "name", "email", "passwordHash", "githubUsername", "githubAccountAuthToken", "googleAccountAuthToken"})

	return &UserExec{ret}
}

func (instance SourceRepositoryExec) Exec(ctx context.Context) (*SourceRepository, error) {
	var v SourceRepository
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SourceRepositoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SourceRepositoryExecArray struct {
	exec *prisma.Exec
}

func (instance SourceRepositoryExecArray) Exec(ctx context.Context) ([]SourceRepository, error) {
	var v []SourceRepository
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SourceRepository struct {
	ID                        string          `json:"id"`
	CreatedAt                 string          `json:"createdAt"`
	UpdatedAt                 string          `json:"updatedAt"`
	SourceProvider            *SourceProvider `json:"sourceProvider,omitempty"`
	Name                      string          `json:"name"`
	AuthClientId              *string         `json:"authClientID,omitempty"`
	AuthSecret                *string         `json:"authSecret,omitempty"`
	CloneStrategy             CloneStrategy   `json:"cloneStrategy"`
	BuildsEnabled             bool            `json:"buildsEnabled"`
	BaseConfigurationFileName string          `json:"baseConfigurationFileName"`
}

type DockerRegistryExec struct {
	exec *prisma.Exec
}

func (instance DockerRegistryExec) Exec(ctx context.Context) (*DockerRegistry, error) {
	var v DockerRegistry
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DockerRegistryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DockerRegistryExecArray struct {
	exec *prisma.Exec
}

func (instance DockerRegistryExecArray) Exec(ctx context.Context) ([]DockerRegistry, error) {
	var v []DockerRegistry
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DockerRegistry struct {
	ID           string `json:"id"`
	CreatedAt    string `json:"createdAt"`
	UpdatedAt    string `json:"updatedAt"`
	Hostname     string `json:"Hostname"`
	AuthUsername string `json:"AuthUsername"`
	AuthPassword string `json:"AuthPassword"`
}

type BuildJobSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BuildJobSubscriptionPayloadExec) Node() *BuildJobExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BuildJob"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "completedAt", "buildHostKind", "buildHostIdentifier", "status", "buildIdentifier", "sourceRevision", "artifactUri", "setupLogs", "buildLogs", "pushLogs"})

	return &BuildJobExec{ret}
}

func (instance *BuildJobSubscriptionPayloadExec) PreviousValues() *BuildJobPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BuildJobPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "completedAt", "buildHostKind", "buildHostIdentifier", "status", "buildIdentifier", "sourceRevision", "artifactUri", "setupLogs", "buildLogs", "pushLogs"})

	return &BuildJobPreviousValuesExec{ret}
}

func (instance BuildJobSubscriptionPayloadExec) Exec(ctx context.Context) (*BuildJobSubscriptionPayload, error) {
	var v BuildJobSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BuildJobSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BuildJobSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BuildJobSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BuildJobSubscriptionPayload, error) {
	var v []BuildJobSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BuildJobSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *BuildJob    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type BuildJobEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BuildJobEdgeExec) Node() *BuildJobExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BuildJob"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "completedAt", "buildHostKind", "buildHostIdentifier", "status", "buildIdentifier", "sourceRevision", "artifactUri", "setupLogs", "buildLogs", "pushLogs"})

	return &BuildJobExec{ret}
}

func (instance BuildJobEdgeExec) Exec(ctx context.Context) (*BuildJobEdge, error) {
	var v BuildJobEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BuildJobEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BuildJobEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BuildJobEdgeExecArray) Exec(ctx context.Context) ([]BuildJobEdge, error) {
	var v []BuildJobEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BuildJobEdge struct {
	Node   BuildJob `json:"node"`
	Cursor string   `json:"cursor"`
}

type DockerRegistryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance DockerRegistryPreviousValuesExec) Exec(ctx context.Context) (*DockerRegistryPreviousValues, error) {
	var v DockerRegistryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DockerRegistryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DockerRegistryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance DockerRegistryPreviousValuesExecArray) Exec(ctx context.Context) ([]DockerRegistryPreviousValues, error) {
	var v []DockerRegistryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DockerRegistryPreviousValues struct {
	ID           string `json:"id"`
	CreatedAt    string `json:"createdAt"`
	UpdatedAt    string `json:"updatedAt"`
	Hostname     string `json:"Hostname"`
	AuthUsername string `json:"AuthUsername"`
	AuthPassword string `json:"AuthPassword"`
}

type DockerRegistrySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *DockerRegistrySubscriptionPayloadExec) Node() *DockerRegistryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "DockerRegistry"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "Hostname", "AuthUsername", "AuthPassword"})

	return &DockerRegistryExec{ret}
}

func (instance *DockerRegistrySubscriptionPayloadExec) PreviousValues() *DockerRegistryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "DockerRegistryPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "Hostname", "AuthUsername", "AuthPassword"})

	return &DockerRegistryPreviousValuesExec{ret}
}

func (instance DockerRegistrySubscriptionPayloadExec) Exec(ctx context.Context) (*DockerRegistrySubscriptionPayload, error) {
	var v DockerRegistrySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DockerRegistrySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DockerRegistrySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance DockerRegistrySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]DockerRegistrySubscriptionPayload, error) {
	var v []DockerRegistrySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DockerRegistrySubscriptionPayload struct {
	Mutation      MutationType    `json:"mutation"`
	Node          *DockerRegistry `json:"node,omitempty"`
	UpdatedFields []string        `json:"updatedFields,omitempty"`
}

type SourceRepositoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance SourceRepositoryPreviousValuesExec) Exec(ctx context.Context) (*SourceRepositoryPreviousValues, error) {
	var v SourceRepositoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SourceRepositoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SourceRepositoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance SourceRepositoryPreviousValuesExecArray) Exec(ctx context.Context) ([]SourceRepositoryPreviousValues, error) {
	var v []SourceRepositoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SourceRepositoryPreviousValues struct {
	ID                        string          `json:"id"`
	CreatedAt                 string          `json:"createdAt"`
	UpdatedAt                 string          `json:"updatedAt"`
	SourceProvider            *SourceProvider `json:"sourceProvider,omitempty"`
	Name                      string          `json:"name"`
	AuthClientId              *string         `json:"authClientID,omitempty"`
	AuthSecret                *string         `json:"authSecret,omitempty"`
	CloneStrategy             CloneStrategy   `json:"cloneStrategy"`
	BuildsEnabled             bool            `json:"buildsEnabled"`
	BaseConfigurationFileName string          `json:"baseConfigurationFileName"`
}

type BuildJobPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BuildJobPreviousValuesExec) Exec(ctx context.Context) (*BuildJobPreviousValues, error) {
	var v BuildJobPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BuildJobPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BuildJobPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BuildJobPreviousValuesExecArray) Exec(ctx context.Context) ([]BuildJobPreviousValues, error) {
	var v []BuildJobPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BuildJobPreviousValues struct {
	ID                  string         `json:"id"`
	CreatedAt           string         `json:"createdAt"`
	UpdatedAt           string         `json:"updatedAt"`
	CompletedAt         *string        `json:"completedAt,omitempty"`
	BuildHostKind       BuildHost      `json:"buildHostKind"`
	BuildHostIdentifier *string        `json:"buildHostIdentifier,omitempty"`
	Status              BuildJobStatus `json:"status"`
	BuildIdentifier     string         `json:"buildIdentifier"`
	SourceRevision      string         `json:"sourceRevision"`
	ArtifactUri         string         `json:"artifactUri"`
	SetupLogs           *string        `json:"setupLogs,omitempty"`
	BuildLogs           *string        `json:"buildLogs,omitempty"`
	PushLogs            *string        `json:"pushLogs,omitempty"`
}

type DockerRegistryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *DockerRegistryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *DockerRegistryConnectionExec) Edges() *DockerRegistryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"DockerRegistryWhereInput", "DockerRegistryOrderByInput", "DockerRegistryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "DockerRegistry"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &DockerRegistryEdgeExecArray{nodes}
}

func (instance *DockerRegistryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateDockerRegistry"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance DockerRegistryConnectionExec) Exec(ctx context.Context) (*DockerRegistryConnection, error) {
	var v DockerRegistryConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DockerRegistryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DockerRegistryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance DockerRegistryConnectionExecArray) Exec(ctx context.Context) ([]DockerRegistryConnection, error) {
	var v []DockerRegistryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DockerRegistryConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []DockerRegistryEdge `json:"edges"`
}

type SourceRepositoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *SourceRepositoryEdgeExec) Node() *SourceRepositoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SourceRepository"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "sourceProvider", "name", "authClientID", "authSecret", "cloneStrategy", "buildsEnabled", "baseConfigurationFileName"})

	return &SourceRepositoryExec{ret}
}

func (instance SourceRepositoryEdgeExec) Exec(ctx context.Context) (*SourceRepositoryEdge, error) {
	var v SourceRepositoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SourceRepositoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SourceRepositoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance SourceRepositoryEdgeExecArray) Exec(ctx context.Context) ([]SourceRepositoryEdge, error) {
	var v []SourceRepositoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SourceRepositoryEdge struct {
	Node   SourceRepository `json:"node"`
	Cursor string           `json:"cursor"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "email", "passwordHash", "githubUsername", "githubAccountAuthToken", "googleAccountAuthToken"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name", "email", "passwordHash", "githubUsername", "githubAccountAuthToken", "googleAccountAuthToken"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}
